---
title: "PCSF: TCGA vs GTEx"
output: html_document
date: "2023-06-02"
---

```{r load packages, include=FALSE}
library(PCSF)
library(plyr)
library(biomaRt)
library(dplyr)
library(tidyr)
library(kableExtra)
library(grid)
library(edgeR)
library(ggplot2)
library(reshape2)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(tidyverse)
library(RobustRankAggreg)
library(progress)


ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
```

## Description

Healthy ovarian cell RNA-seq data was downloaded from GTEx and differential expression was performed comparing it with data from the TCGA-OV project. 

<br>

## Step 1: Query the TCGA database and obtain TCGA-OV project data. Also load GTEx data

<br>

<details>
<summary> Show code </summary>
```{r data prep, eval=FALSE}
# query TCGA for TCGA-OV project data
query_TCGA <- GDCquery(project = "TCGA-OV",
                      experimental.strategy = "RNA-Seq",
                      data.category = "Transcriptome Profiling",
                      data.type = "Gene Expression Quantification",
                      access = "open")

output_query_TCGA <- getResults(query_TCGA)

# check sample types
table(output_query_TCGA$sample_type)


# get clinical data
clinical_query_TCGA_OV <- GDCquery_clinic(project = "TCGA-OV",
                                          type = "clinical")

TCGA_OV_clinical_data <- subset(clinical_query_TCGA_OV, select = c("project", "submitter_id", "figo_stage", "tissue_or_organ_of_origin"))


# combine stage ID with sample info
master_df <- merge(TCGA_OV_clinical_data, output_query_TCGA, by.x = "submitter_id", by.y = "cases.submitter_id")
master_df <- subset(master_df, select = c("project.x", "figo_stage", "cases", "file_name", "sample_type", "tissue_or_organ_of_origin"))
colnames(master_df)[6] <- "primary_site"

# check number of stages included
table(master_df$figo_stage, useNA = "always")

# download and prepare TCGA-OV project data
GDCdownload(query_TCGA, directory = "no_gepia/")

TCGA_OV_data <- GDCprepare(query_TCGA, summarizedExperiment = TRUE, directory = "no_gepia/")
TCGA_OV_data_unstranded <- assay(TCGA_OV_data, "unstranded")

# format rownames
rownames(TCGA_OV_data_unstranded) <- gsub("\\.\\d+", "", rownames(TCGA_OV_data_unstranded))
TCGA_OV_data_unstranded <- as.data.frame(TCGA_OV_data_unstranded)

# load GTEx data
GTEx_raw <- read.table("no_gepia/gene_reads_2017-06-05_v8_ovary.gct", skip = 2, header = T)

# format to match TCGA data
GTEx_data <- GTEx_raw[, -c(1:3)]
rownames(GTEx_data) <- GTEx_raw$Name
rownames(GTEx_data) <- gsub("\\.\\d+", "", rownames(GTEx_data))

save(TCGA_OV_data_unstranded, GTEx_data, file = "no_gepia/TCGA_OV_data_unstranded.RData")
```
</details>

<br>

## Step 2: Remove non-active genes across all samples

non active = FLASE
```{r non-active genes, echo=FALSE}
load("no_gepia/raw_data.RData")

merged_df <- inner_join(TCGA_OV_data_unstranded, GTEx_data, by = c("row_names_TCGA" = "row_names_GTEx"))

rownames(merged_df) <- merged_df$row_names_TCGA

raw_gene_list <- nrow(merged_df)


colnames(merged_df)[1] <- "gene_id"
gene_id <- merged_df$gene_id
merged_df <- merged_df[, -1] # remove gene ids for rowSums calc

# subset genes that have a cpm of greater than one in more than 50% of the samples
keepTheseGenes <- (rowSums(cpm(merged_df) > 1) >= ncol(merged_df)/2)
print(summary(keepTheseGenes))

# add gene ids back into df
merged_df <- cbind(gene_id, merged_df)

removedGenes <- merged_df$gene_id[!keepTheseGenes]
removedGenes <- as.data.frame(removedGenes)
colnames(removedGenes)[1] <- "gene_id"

merged_df <- merged_df[keepTheseGenes, ]

initial_subset <- nrow(merged_df)
```

<br>

## Step 3: Differential expression analysis using edgeR

```{r edgeR, echo=FALSE}
merged_df <- merged_df[, -1]

# Select the columns that start with "TCGA"
cols <- grep("^TCGA", colnames(merged_df))

# Assign the unstranded columns to the cancer group
cancer <- colnames(merged_df)[cols]

# Assign the rest of the columns to the healty group
benign <- setdiff(colnames(merged_df), cancer)

# Create the group variable
group <- factor(c(rep("cancer", length(cancer)), rep("benign", length(benign))))

data <- DGEList(counts = merged_df, group = group)

design <- model.matrix(~group)

# Estimate a common negative binomial dispersion parameter for a DGE dataset with a general experimental design
common <- estimateGLMCommonDisp(data, design, verbose = T)

# Estimate the abundance-dispersion trend by Cox-Reid approximate profile likelihood.
trend <- estimateGLMTrendedDisp(common, design)

# Compute an empirical Bayes estimate of the negative binomial dispersion parameter for each tag, 
# with expression levels specified by a log-linear model.
tagwise <- estimateGLMTagwiseDisp(trend, design)

# Fit a negative binomial generalized log-linear model to the read counts for each gene. 
# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
fit <- glmFit(tagwise, design)

# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
lrt <- glmLRT(fit, coef = 2)

# Extract the most differentially expressed genes (or sequence tags) from a test object, 
# ranked either by p-value or by absolute log-fold-change.
toptags <- topTags(lrt, n = Inf)

# Identify which genes are significantly differentially expressed from 
# an edgeR fit object containing p-values and test statistics.
dif_exp <- decideTestsDGE(lrt, p = 0.05, adjust = "fdr", lfc = 2)
print(summary(dif_exp))

dif_exp_genes <- rownames(tagwise)[as.logical(dif_exp)]

# create a results df
hits <- toptags$table[toptags$table$FDR < 0.1, ]
colnames <- colnames(hits)
hits$gene_id <- rownames(hits)
hits <- hits[,c("gene_id", colnames)]

dif_exp <- hits[dif_exp_genes, ]

write.csv(dif_exp, "no_gepia/edgeR_dif_exp_genes.csv")
```

```{r plot edgeR, echo=FALSE, out.width='33%', fig.show='hold'}
# Plot the genewise biological coefficient of variation (BCV) against gene abundance (in log2 counts per million).
plotBCV(tagwise, main = "biological coefficient of variation")

# Make a mean-difference plot of two libraries of count data with smearing of points with very low counts, 
# especially those that are zero for one of the columns.
plotSmear(lrt, de.tags = dif_exp_genes, main = "Mean-difference plot")

# plot Pvalues of different logFC scores
ggplot(hits, aes(x=logFC, y=-log(FDR))) + geom_point() + labs(title = "Adjusted logFC")
```

<br>

## Step 4: PCSF file prep - Create score file and format STRING interaction data

-   Convert gene ensembl to gene symbol

-   Create score file from logFC values

-   Feed list of proteins into STRING/Cytoscape

-   Format output and create interaction file

<br>

<details>
<summary>Show code + removed genes</summary>
```{r missing genes}
# read in the data
data <- read.csv("no_gepia/edgeR_dif_exp_genes.csv")

# subset the gene_id and logFC columns
data <- subset(data, select = c("gene_id", "logFC"))

# convert to gene symbol
uniprot_id <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = data$gene_id, 
                       mart = ensembl)

# remove empty rows
uniprot_id <- subset(uniprot_id, external_gene_name != "")

# check for duplicate uniprot ids
uniprot_id <- distinct(uniprot_id)

# merge back with original data
colnames(uniprot_id)[1] <- "gene_id"

uniprot_data <- merge(uniprot_id, data, by = "gene_id")

uniprot_data <- subset(uniprot_data, select = c("external_gene_name", "logFC"))

# check to see if genes that at all genes were converted at least once
missing_genes <- anti_join(data, uniprot_id, by = "gene_id")

# create score file
write.csv(uniprot_data, "no_gepia/pcsf_score.csv")

# create ensemble protein list for interaction db
write.table(uniprot_data$external_gene_name, "no_gepia/gene_list.txt", row.names = F, col.names = F, quote = F)
```

```{r format cytoscape, echo=FALSE}
string_edge_data <- read.table("no_gepia/STRING network (physical) default edge.csv", header = T, sep = ",", stringsAsFactors = F)
ppi_list <- subset(string_edge_data, select = c("name", "stringdb..score"))
ppi_list <- ppi_list %>% 
  separate(name, sep = " ", into = c("node_1", "del", "node_2"))
ppi_list <- subset(ppi_list, select = c("node_1", "node_2", "stringdb..score"))
ppi_list$node_1 <- gsub(".*.\\.", "", ppi_list$node_1)
ppi_list$node_2 <- gsub(".*.\\.", "", ppi_list$node_2)

string_node_data <- read.table("no_gepia/STRING network (physical) default node.csv", header = T, sep = ",", stringsAsFactors = F)
node_list <- subset(string_node_data, select = c("name", "query.term"))
node_list$name <- gsub(".*.\\.", "", node_list$name)
ppi_list$original_order <- seq_len(nrow(ppi_list))
merged_df <- merge(ppi_list, node_list, by.x = "node_1", by.y = "name", all.x = TRUE)
merged_df <- merge(merged_df, node_list, by.x = "node_2", by.y = "name", all.x = TRUE)
merged_df <- merged_df[order(merged_df$original_order), ]

final_df <- merged_df[, c("query.term.x", "query.term.y", "stringdb..score")]
colnames(final_df) <- c("node_1", "node_2", "score")

write.csv(final_df, "no_gepia/interaction_score.csv")


# create gene_id uniprot_id ref list.
ref_list <- getBM(attributes = c("external_gene_name","uniprot_gn_id"),
                  filters = "external_gene_name", 
                  values = node_list$query.term, 
                  mart = ensembl)
```
</details>

<br>

## Step 5: Run PCSF and create cross reference results with AF structures for durggability

```{r PCSF, echo=FALSE}
# set seed for reproducibility 
set.seed(1234)

# read in STRING data
string_data <- read.csv("no_gepia/interaction_score.csv", row.names = 1)

# construct interactome
ppi <- construct_interactome(string_data)

# read in score file
data <- read.csv("no_gepia/pcsf_score.csv", row.names = 1)

# set terminals
terminals <- setNames(as.numeric(data$logFC), data$external_gene_name)

# run PCSF with random noise

# time a pcsf run
start_time <- Sys.time()
subnet <- PCSF_rand(ppi, terminals, n = 50, r = 0.1, w = 2, b = 1, mu = 0.0005)
elapsed_time <- Sys.time() - start_time
print(elapsed_time)

plot.PCSF(subnet, node_label_cex = 15)
```

<br>

```{r PCSF data, include=FALSE}
# extract cluster data
clust <- clusters(subnet)
df <- data.frame(gene_id = names(clust$membership), cluster = factor(clust$membership))
betweenness <- betweenness(subnet) 
centrality <- degree(subnet) 
df$betweenness <- betweenness[as.character(df$gene_id)]
df$degree_centrality <- centrality[as.character(df$gene_id)]
df$betweenness <- as.integer(df$betweenness)
df$degree_centrality <- as.integer(df$degree_centrality)

df <- df[order(-df$degree_centrality), ]

rownames(df) <- NULL

write.csv(df, "no_gepia/pcsf_results.csv", row.names = F)
```

```{r merge AF data, include=FALSE}
# read in data
af_drugability <- read.csv("../../druggability_results/fpocket_druggability.csv")
pcsf_result <- read.csv("no_gepia/pcsf_results.csv")
pcsf_result <- merge(ref_list, pcsf_result, by.x = "external_gene_name", by.y = "gene_id")

# merge AF data with PCSF data by uniprot ID
pcsf_master <- merge(pcsf_result, af_drugability, by.x = "uniprot_gn_id", by.y = "uniprot_id")

pcsf_master <- pcsf_master[order(-pcsf_master$druggability), ]

druggability_crossref <- nrow(pcsf_master)

write.csv(pcsf_master, "no_gepia/PCSF_drugability.csv")
```

Note: The citation scores for this data were generated outside this R script using PubMed API

```{r citation scores, echo=FALSE}
# add up and down regulaiton tags to table
up_or_down <- read.csv("no_gepia/pcsf_score.csv", row.names = 1)
up_or_down$regulation <- ifelse(up_or_down$logFC > 0, "up_reg", "dn_reg")
colnames(up_or_down)[1] <- "gene_id"
pcsf_master <- read.csv("no_gepia/PCSF_drugability.csv", row.names = 1)
pcsf_master <- merge(pcsf_master, up_or_down, by.x = "external_gene_name", by.y = "gene_id")

# run the citation score script now using PCSF_drugability.csv

# add citation scores
cit_scores <- read.csv("no_gepia/citation_scores.csv")
pcsf_master <- merge(pcsf_master, cit_scores, by.x = "external_gene_name", by.y = "gene_id")

pcsf_master <- distinct(pcsf_master)
pcsf_master <- pcsf_master[order(-pcsf_master$druggability), ]
rownames(pcsf_master) <- NULL


# remove duplicates
master_unique <- pcsf_master %>%
  group_by(external_gene_name) %>%
  filter(druggability == max(druggability))

rownames(master_unique) <- NULL

write.csv(pcsf_master, "no_gepia/pcsf_master.csv")
```

<details>

<summary>Show raw table</summary>

```{r tabulate, echo=FALSE}
kable(pcsf_master, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

Note: Duplicates removed here

```{r tabulate unique, echo=FALSE}
kable(master_unique, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

<details>

```{r eval=FALSE}
# dont need it, doenst work
subset_genes <- as.data.frame(pcsf_master$gene_id)
colnames(subset_genes)[1] <- "gene_id"

network_out_genes <- anti_join(uniprot_id, subset_genes, by = "gene_id")

kable(network_out_genes, format = "html", caption = "Removed genes from cytoscape + network + druggability filters") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

## Step 4: Functional Enrichment Analysis

<details>

<summary>Show code</summary>

```{r enrichment, echo=FALSE}
enrichment_analysis_edit <-function(subnet, mode=NULL, gene_universe){
  
  # Checking function arguments
  if (missing(subnet))
    stop("Need to specify the subnetwork obtained from the PCSF algorithm.")
  if (class(subnet)[1] != "PCSF" || class(subnet)[2] != "igraph")
    stop("The subnetwork must be a \"PCSF\" object derived from an \"igraph\" class.")
  if (!is.null(mode)){
    if(mode==1 && missing(gene_universe))
      stop("Need to specify a list of genes (vector of gene symbols) used as background in enrichment analysis by topGO package")
  }
  
  
  cat("  Performing enrichment analysis...\n\n")
  
  # Obtain clusters in the subnet using edge betweenness clustering algorithm from igraph package.
  clusters = cluster_edge_betweenness(subnet)
  
  # Perform ebrichment analysis for each cluster using EnrichR through its API or topGO.
  #print("Performing enrichment analysis...")
  #print(paste("Number of clusters:", length(clusters$membership)))
  
  havingInternet <- function() {
    if (.Platform$OS.type == "windows") {
      ipmessage <- system("ipconfig", intern = TRUE)
    } else {
      ipmessage <- system("ifconfig", intern = TRUE)
    }
    validIP <- "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)[.]){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    any(grep(validIP, ipmessage))
  }
  
  internet_connection <- havingInternet()
  
  if(!is.null(mode)){
    if(mode==0){
      if(internet_connection){
        cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
        enrich = call_enr(clusters, mode = 0, gene_universe)
      }
      else{
        stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
      }
    }
    else{
      cat("  Enrichment is being performed by topGO package ...\n")
      enrich = call_enr(clusters, mode = mode, gene_universe)
    }
  }
  else
  {
    if(internet_connection){
      cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
      enrich = call_enr(clusters, mode = 0, gene_universe)
    }
    else{
      stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
    }
  }
  
  if('Compound'%in% V(subnet)$type){##then we have drugs!
    require(dplyr)
    comps=data.frame(Drug=V(subnet)$name[which(V(subnet)$type=='Compound')],
                     Cluster=clusters$membership[which(V(subnet)$type=='Compound')])%>%
      dplyr::group_by(Cluster)%>%
      dplyr::summarise(DrugsByBetweenness=paste(Drug,collapse=';'))
    
  }
  else{
    comps <-NULL
  }
  enrichment = enrich[[1]]
  enrichment_complete = enrich[[2]]
  print(paste("Number of enrichment results:", length(enrichment_complete)))
  
  #for (x in 1:length(enrichment_complete)) {
  #  print(paste("Cluster", x, "enrichment complete:", enrichment_complete[[x]]))
  #}
  
  novals<-which(unlist(sapply(enrich[[2]],function(x) is.null(dim(x)))))
  if(length(novals)>0)
    enrichment_complete <- enrichment_complete[-novals]
  
  enrichment_tab <- do.call(rbind, lapply(seq_along(enrichment_complete), function(x) {
    if (!is.null(dim(enrichment_complete[[x]]))) {
      data.frame(Cluster = x, enrichment_complete[[x]])
    } else {
      NULL
    }
  }))
  
  more.than.two <- which(sapply(enrichment_tab$Genes, function(x) length(unlist(strsplit(x, split = ';')))) > 2)
  if (length(more.than.two) > 0)
    enrichment_tab <- enrichment_tab[more.than.two, ]
  
  if(!is.null(comps))
    enrichment_tab = enrichment_tab%>%dplyr::left_join(comps,by='Cluster')
  
  # Add 'group" and 'title' attributes to subnet
  V(subnet)$group = clusters$membership
  V(subnet)$title = paste0("Cluster ",clusters$membership,": Enrichment analysis")
  for( i in 1:length(V(subnet))){
    V(subnet)$title[i] = paste0( V(subnet)$title[i], enrichment[[V(subnet)$group[i]]])
  }
  
  # Derive a "PCSFe" object from an "igraph" class.
  class(subnet) <- c("PCSFe", "igraph")
  # Combine the subnetwork and colplete enrichment analysis tables.
  output = list(subnet, enrichment_tab)
  names(output) = c("subnet", "enrichment")
  
  return (output)
}

# functional enrichment using enrichR
res <- enrichment_analysis_edit(subnet)
```

</details>

<br>

#### Tip: Hover over nodes for details!

```{r plot enrichment, echo=FALSE}
plot.PCSFe(res$subnet, edge_width = 8, node_size = 30, node_label_cex = 1)
```

<br>

Note: P-value represents likelihood of observing that pathway by random chance. The top 15 functional enrichment terms for each cluster are ranked according to the adjusted p-value. This is what you observe when you hover your mouse over a node in that cluster.

<br>

```{r enrichment data, include=FALSE}
enrichment_results <- res$enrichment

# Create a data frame with the enrichment results
enrichment_table <- data.frame(
  Cluster = enrichment_results$Cluster,
  Term = enrichment_results$Term,
  PValue = enrichment_results$P.value,
  Adjusted_Pvalue = enrichment_results$Adjusted.P.value,
  Genes = enrichment_results$Genes)

write.csv(enrichment_table, "no_gepia/enrichment_results.csv")
```

#### Tabulated format

```{r enrichment table, echo=FALSE}
enrichment_table <- read.csv("no_gepia/enrichment_results.csv", row.names = 1)
  
kable(enrichment_table, format = "html", caption = "Enrichment Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<br>

In this table the genes are ordered by their combined rank score which is a normalised score with the following contributions:

-   Betweeness: 10%
-   Citation score: 20%
-   Degree centrality: 30%
-   Druggability: 40%

<br>

```{r custom weighting, echo=FALSE}
# normalize scores for overall rank
pcsf_master <- read.csv("no_gepia/pcsf_master.csv", row.names = 1)

betweeness_norm <- (pcsf_master$betweenness - min(pcsf_master$betweenness)) / (max(pcsf_master$betweenness) - min(pcsf_master$betweenness))

centrality_norm <- (pcsf_master$degree_centrality - min(pcsf_master$degree_centrality)) / (max(pcsf_master$degree_centrality) - min(pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

# Custom weights
betweeness_w <- 0.10
citation_w <- 0.20
centrality_w <- 0.30
druggability_w <- 0.40


# Combine scores using custom weights
combined_score <- betweeness_w * betweeness_norm +
  centrality_w * centrality_norm +
  druggability_w * pcsf_master$druggability -
  citation_w * citation_norm

pcsf_master_edit <- cbind(pcsf_master, combined_score)

pcsf_master_edit <- pcsf_master_edit[order(-pcsf_master_edit$combined_score), ]

pcsf_master_edit_unique <- pcsf_master_edit[!duplicated(pcsf_master_edit$external_gene_name), ]
rownames(pcsf_master_edit_unique) <- NULL

rownames(pcsf_master_edit) <- NULL

kable(pcsf_master_edit, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<details>

<summary>Show unique genes only</summary>

```{r tabulate master_unique}
kable(pcsf_master_edit_unique, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

<br>

<br>

The next section of this document is dedicated to the ranking of genes based on a combination of scoring methods. There are two primary methods:

* Rank sensitivity: This method is something I built which test all possible weight combinations for each of the score types. It it is difficult to add new score types ot this method as the code is complex and potentially not optimised and would take a good amount of time to do so. Not to say it will never happen.

* Robust Rank Aggregation (RRA): This is a cited method for aggregating ranked lists, especially lists of genes. The function is far easier to use than the rank sensitivity code and new data types are easily interchangable

<details>
<summary>Addtional Info</summary>

Included here is the addition of cryptic pocket scores which were analysed in python using the same AlphaFold structures as done with Fpocket. Any structures less than 80 amino acids in length were removed per the PocketMiner methodology. Using a 10 amino acid "window" average, pockets are calculated per amino acid (also as per PocketMiner methodology). The rank sensitivity test was not performed with the PocketMiner data becasue its not very easy to include new data types like the rank aggregation. Can be done if required but the first comparison shows they return similar results anyway so not much value in running again if rank aggregation method is far better. It also has the benefit of being accompanied by a comprehensive study for the method.

</details>

The Robust Rank Aggregation All tab includes the following data:

* Degree centrality
* Betweeness
* Citation score
* Druggability score
* Number of druggable pockets
* Cryptic pocket score
* Number of cryptic Pockets

<br>

##  {.tabset .tabset-pills}

### Rank Sensitivity
```{r Rank Sensitivity, echo=FALSE}
# Define the number of weight values (genes in top x) to test (including 0)
num_weights <- 11

# Create weight value sequences that sum up to 1
betweeness_w_values <- seq(0, 1, length.out = num_weights)
citation_w_values <- seq(0, 1, length.out = num_weights)
centrality_w_values <- seq(0, 1, length.out = num_weights)
druggability_w_values <- seq(0, 1, length.out = num_weights)

# Calculate the total number of iterations
total_iterations <- num_weights ^ 4

# Create a progress bar
pb <- progress_bar$new(total = total_iterations)

# Create an empty data frame with proper column names
sensitivity_results <- data.frame(
  betweeness_weight = numeric(),
  citation_weight = numeric(),
  centrality_weight = numeric(),
  druggability_weight = numeric(),
  top_genes = character(),
  stringsAsFactors = FALSE
)

# Perform sensitivity test
for (betweeness_w in betweeness_w_values) {
  for (citation_w in citation_w_values) {
    for (centrality_w in centrality_w_values) {
      for (druggability_w in druggability_w_values) {
        # Check if the weights sum up to 1
        if (betweeness_w + citation_w + centrality_w + druggability_w == 1) {
          # Combine scores using current weights
          combined_score <- betweeness_w * betweeness_norm +
            centrality_w * centrality_norm +
            druggability_w * pcsf_master$druggability -
            citation_w * citation_norm
          
          # Rank the genes based on the combined score
          pcsf_master_edit <- pcsf_master
          pcsf_master_edit$combined_score <- combined_score
          pcsf_master_edit <- pcsf_master_edit[order(-pcsf_master_edit$combined_score), ]
          
          # Select the top 10 genes
          top_genes <- head(pcsf_master_edit$external_gene_name, 10)
          
          # Add results to the sensitivity_results data frame
          sensitivity_results <- rbind(sensitivity_results, list(
            betweeness_weight = betweeness_w,
            citation_weight = citation_w,
            centrality_weight = centrality_w,
            druggability_weight = druggability_w,
            top_genes = paste(top_genes, collapse = ', ')
          ))
        }
        
        # Increment the progress bar
        pb$tick()
      }
    }
  }
}


# Split the "top_genes" column into a list of genes
sensitivity_results$top_genes_list <- strsplit(sensitivity_results$top_genes, ', ')

# Count the occurrences of each gene
all_genes <- unlist(sensitivity_results$top_genes_list)
all_genes_unique <- unique(all_genes)
count <- sapply(all_genes_unique, function(g) sum(sapply(sensitivity_results$top_genes_list, function(lst) g %in% lst)))

# Create an empty data frame to store gene counts
gene_counts <- data.frame(
  gene = all_genes_unique,
  count = count,
  stringsAsFactors = FALSE
)

# Sort the gene counts by count
gene_counts <- gene_counts[order(-gene_counts$count), ]



counts_when_betweeness_0 <- sensitivity_results[
  sensitivity_results$betweeness_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "druggability_weight")]) != 0, 
  ]
counts_when_betweeness_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_betweeness_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_betweeness_0)

counts_when_centrality_0 <- sensitivity_results[
  sensitivity_results$centrality_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "betweeness_weight", "druggability_weight")]) != 0, 
]
counts_when_centrality_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_centrality_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_centrality_0)

counts_when_citation_0 <- sensitivity_results[
  sensitivity_results$citation_weight == 0 &
    rowSums(sensitivity_results[, c("betweeness_weight", "centrality_weight", "druggability_weight")]) != 0, 
]
counts_when_citation_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_citation_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_citation_0)

counts_when_druggability_0 <- sensitivity_results[
  sensitivity_results$druggability_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight")]) != 0, 
]
counts_when_druggability_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_druggability_0$top_genes_list, function(lst) g %in% lst)))

tcga_gene_counts <- cbind(gene_counts, counts_when_druggability_0)

# add gene description
gene_description <- getBM(attributes = c("external_gene_name", "description"), 
                          filters = "external_gene_name", 
                          values = tcga_gene_counts$gene, 
                          mart = ensembl)

tcga_gene_counts <- merge(gene_description, tcga_gene_counts, by.x = "external_gene_name", by.y = "gene")

tcga_gene_counts <- tcga_gene_counts[order(-tcga_gene_counts$count), ]

rownames(tcga_gene_counts) <- NULL

kable(tcga_gene_counts, format = "html", caption = "Rank Sensitivity") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```


### Robust Rank Aggregation (RRA)

```{r Robust Rank Aggregation, echo=FALSE}
# Robust Rank Agrregation
betweenness <- subset(pcsf_master_edit_unique, select = c("ID", "betweenness"))
betweenness <- distinct(betweenness)
betweenness$betweenness <- (betweenness$betweenness - min(betweenness$betweenness)) / (max(betweenness$betweenness) - min(betweenness$betweenness))
betweenness <- betweenness[order(betweenness$betweenness, decreasing = T), ]
betweenness <- betweenness$ID

centrality <- subset(pcsf_master_edit_unique, select = c("ID", "degree_centrality"))
centrality <- distinct(centrality)
centrality$degree_centrality <- (centrality$degree_centrality - min(centrality$degree_centrality)) / (max(centrality$degree_centrality) - min(centrality$degree_centrality))
centrality <- centrality[order(centrality$degree_centrality, decreasing = T), ]
centrality <- centrality$ID

# log transformation of citation scores
citation <- subset(pcsf_master_edit_unique, select = c("ID", "citation_score"))
citation <- distinct(citation)
citation$citation_score <- log(citation$citation_score + 1)
citation$citation_score <- (citation$citation_score - min(citation$citation_score)) / (max(citation$citation_score) - min(citation$citation_score))
citation <- citation[order(citation$citation_score, decreasing = F), ]
citation <- citation$ID

druggability_data <- subset(pcsf_master_edit_unique, select = c("ID", "druggability", "num_drug_pockets"))
druggability_data <- distinct(druggability_data)
druggability <- druggability_data[order(druggability_data$druggability, decreasing = T), ]
druggability <- druggability$ID

num_drug_pockets <- druggability_data[order(druggability_data$num_drug_pockets, decreasing = T), ]
num_drug_pockets <- num_drug_pockets$ID

rankings <- list(betweenness, centrality, citation, druggability, num_drug_pockets)

aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(pcsf_master_edit_unique, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

# remove scientific notation
options(scipen=999)

description <- getBM(attributes = c("external_gene_name", "description"), 
                                     filters = "external_gene_name", 
                                     values = aggregate_ranks$external_gene_name, 
                                     mart = ensembl)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

rownames(aggregate_ranks) <- NULL

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```

### RRA w/ cryptic pocket
```{r RRA + cryptic pockets, echo=FALSE}
# Robust Rank Agrregation
betweenness <- subset(pcsf_master_edit_unique, select = c("ID", "betweenness"))
betweenness <- distinct(betweenness)
betweenness$betweenness <- (betweenness$betweenness - min(betweenness$betweenness)) / (max(betweenness$betweenness) - min(betweenness$betweenness))
betweenness <- betweenness[order(betweenness$betweenness, decreasing = T), ]
betweenness <- betweenness$ID

centrality <- subset(pcsf_master_edit_unique, select = c("ID", "degree_centrality"))
centrality <- distinct(centrality)
centrality$degree_centrality <- (centrality$degree_centrality - min(centrality$degree_centrality)) / (max(centrality$degree_centrality) - min(centrality$degree_centrality))
centrality <- centrality[order(centrality$degree_centrality, decreasing = T), ]
centrality <- centrality$ID

# log transformation of citation scores
citation <- subset(pcsf_master_edit_unique, select = c("ID", "citation_score"))
citation <- distinct(citation)
citation$citation_score <- log(citation$citation_score + 1)
citation$citation_score <- (citation$citation_score - min(citation$citation_score)) / (max(citation$citation_score) - min(citation$citation_score))
citation <- citation[order(citation$citation_score, decreasing = F), ]
citation <- citation$ID

druggability_data <- subset(pcsf_master_edit_unique, select = c("ID", "druggability", "num_drug_pockets"))
druggability_data <- distinct(druggability_data)
druggability <- druggability_data[order(druggability_data$druggability, decreasing = T), ]
druggability <- druggability$ID

num_drug_pockets <- druggability_data[order(druggability_data$num_drug_pockets, decreasing = T), ]
num_drug_pockets <- num_drug_pockets$ID

# add the PocketMiner data as another ranking
pocketminer_data <- read.csv("../../pocketminer/results/pocketminer_results.csv")
pocketminer_data <- pocketminer_data[pocketminer_data$ID %in% pcsf_master_edit_unique$ID, ]

pocketminer_data <- pocketminer_data[order(pocketminer_data$max_hit, decreasing = T), ]
cryptic_pockets <- pocketminer_data$ID

# reorder for num_hits
pocketminer_data <- pocketminer_data[order(pocketminer_data$num_hits, decreasing = T), ]
num_cryp_pockets <- pocketminer_data$ID

rankings <- list(betweenness, centrality, citation, druggability, cryptic_pockets)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(pcsf_master_edit_unique, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

description <- getBM(attributes = c("external_gene_name", "description"), 
                                     filters = "external_gene_name", 
                                     values = aggregate_ranks$external_gene_name, 
                                     mart = ensembl)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]
rownames(aggregate_ranks) <- NULL

# remove scientific notation
options(scipen=999)

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```



### RRA with all data
```{r RRA all, echo=FALSE}
# Robust Rank Agrregation
betweenness <- subset(pcsf_master_edit_unique, select = c("ID", "betweenness"))
betweenness <- distinct(betweenness)
betweenness$betweenness <- (betweenness$betweenness - min(betweenness$betweenness)) / (max(betweenness$betweenness) - min(betweenness$betweenness))
betweenness <- betweenness[order(betweenness$betweenness, decreasing = T), ]
betweenness <- betweenness$ID

centrality <- subset(pcsf_master_edit_unique, select = c("ID", "degree_centrality"))
centrality <- distinct(centrality)
centrality$degree_centrality <- (centrality$degree_centrality - min(centrality$degree_centrality)) / (max(centrality$degree_centrality) - min(centrality$degree_centrality))
centrality <- centrality[order(centrality$degree_centrality, decreasing = T), ]
centrality <- centrality$ID

# log transformation of citation scores
citation <- subset(pcsf_master_edit_unique, select = c("ID", "citation_score"))
citation <- distinct(citation)
citation$citation_score <- log(citation$citation_score + 1)
citation$citation_score <- (citation$citation_score - min(citation$citation_score)) / (max(citation$citation_score) - min(citation$citation_score))
citation <- citation[order(citation$citation_score, decreasing = F), ]
citation <- citation$ID

druggability_data <- subset(pcsf_master_edit_unique, select = c("ID", "druggability", "num_drug_pockets"))
druggability_data <- distinct(druggability_data)
druggability <- druggability_data[order(druggability_data$druggability, decreasing = T), ]
druggability <- druggability$ID

num_drug_pockets <- druggability_data[order(druggability_data$num_drug_pockets, decreasing = T), ]
num_drug_pockets <- num_drug_pockets$ID

# add the PocketMiner data as another ranking
pocketminer_data <- read.csv("../../pocketminer/results/pocketminer_results.csv")
pocketminer_data <- pocketminer_data[pocketminer_data$ID %in% pcsf_master_edit_unique$ID, ]

pocketminer_data <- pocketminer_data[order(pocketminer_data$max_hit, decreasing = T), ]
cryptic_pockets <- pocketminer_data$ID

# reorder for num_hits
pocketminer_data <- pocketminer_data[order(pocketminer_data$num_hits, decreasing = T), ]
num_cryp_pockets <- pocketminer_data$ID

rankings <- list(betweenness, centrality, citation, druggability, num_drug_pockets, cryptic_pockets, num_cryp_pockets)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(pcsf_master_edit_unique, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

description <- getBM(attributes = c("external_gene_name", "description"), 
                                     filters = "external_gene_name", 
                                     values = aggregate_ranks$external_gene_name, 
                                     mart = ensembl)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]
rownames(aggregate_ranks) <- NULL

# remove scientific notation
options(scipen=999)

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```

### RRA: Cryptic Pocket Instead of druggability

```{r cryp pockets instead of druggability, echo=FALSE}
# Robust Rank Agrregation
betweenness <- subset(pcsf_master_edit_unique, select = c("ID", "betweenness"))
betweenness <- distinct(betweenness)
betweenness$betweenness <- (betweenness$betweenness - min(betweenness$betweenness)) / (max(betweenness$betweenness) - min(betweenness$betweenness))
betweenness <- betweenness[order(betweenness$betweenness, decreasing = T), ]
betweenness <- betweenness$ID

centrality <- subset(pcsf_master_edit_unique, select = c("ID", "degree_centrality"))
centrality <- distinct(centrality)
centrality$degree_centrality <- (centrality$degree_centrality - min(centrality$degree_centrality)) / (max(centrality$degree_centrality) - min(centrality$degree_centrality))
centrality <- centrality[order(centrality$degree_centrality, decreasing = T), ]
centrality <- centrality$ID

# log transformation of citation scores
citation <- subset(pcsf_master_edit_unique, select = c("ID", "citation_score"))
citation <- distinct(citation)
citation$citation_score <- log(citation$citation_score + 1)
citation$citation_score <- (citation$citation_score - min(citation$citation_score)) / (max(citation$citation_score) - min(citation$citation_score))
citation <- citation[order(citation$citation_score, decreasing = F), ]
citation <- citation$ID

druggability_data <- subset(pcsf_master_edit_unique, select = c("ID", "druggability", "num_drug_pockets"))
druggability_data <- distinct(druggability_data)
druggability <- druggability_data[order(druggability_data$druggability, decreasing = T), ]
druggability <- druggability$ID

num_drug_pockets <- druggability_data[order(druggability_data$num_drug_pockets, decreasing = T), ]
num_drug_pockets <- num_drug_pockets$ID

# add the PocketMiner data as another ranking
pocketminer_data <- read.csv("../../pocketminer/results/pocketminer_results.csv")
pocketminer_data <- pocketminer_data[pocketminer_data$ID %in% pcsf_master_edit_unique$ID, ]

pocketminer_data <- pocketminer_data[order(pocketminer_data$max_hit, decreasing = T), ]
cryptic_pockets <- pocketminer_data$ID

# reorder for num_hits
pocketminer_data <- pocketminer_data[order(pocketminer_data$num_hits, decreasing = T), ]
num_cryp_pockets <- pocketminer_data$ID

rankings <- list(betweenness, centrality, citation, cryptic_pockets, num_cryp_pockets)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(pcsf_master_edit_unique, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

description <- getBM(attributes = c("external_gene_name", "description"), 
                                     filters = "external_gene_name", 
                                     values = aggregate_ranks$external_gene_name, 
                                     mart = ensembl)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]
rownames(aggregate_ranks) <- NULL

# remove scientific notation
options(scipen=999)

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```

##

<br>

### Gene subset progression

<br>

```{r echo=FALSE}
edgeR_hits_dif_exp <- nrow(dif_exp)
ensembl_gene_converted <- nrow(uniprot_id)
cytoscape_string <- nrow(node_list)
pcsf_subnet <- length(subnet)
unique_ids <- nrow(pcsf_master_edit_unique)

# create summary
cat(paste("Raw gene list =", raw_gene_list, "--> Initial subset (>1 in >=0.5) =", initial_subset))
cat(paste("Initial subset =", initial_subset, "--> EdgeR hits (only dif exp genes) =", edgeR_hits_dif_exp))
cat(paste("EdgeR hits =", edgeR_hits_dif_exp, "--> ensembl gene converted =", ensembl_gene_converted))
cat(paste("ensembl gene converted =", ensembl_gene_converted, "--> Cytoscape/STRING =", cytoscape_string))
cat(paste("Cytoscape/STRING =", cytoscape_string, "--> PCSF subnet =", pcsf_subnet))
cat(paste("PCSF subnet =", pcsf_subnet, "--> Druggability CrossRef =", druggability_crossref))
cat(paste("Druggability CrossRef =", druggability_crossref, "--> Unique IDs =", unique_ids))
```

<br>

<br>

end of doc