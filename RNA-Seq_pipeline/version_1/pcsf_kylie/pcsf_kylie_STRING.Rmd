---
title: "PCSF: Kylie Data, STRING"
output: html_document
date: "2023-06-02"
---

```{r include=FALSE}
library(PCSF)
library(plyr)
library(biomaRt)
library(dplyr)
library(tidyr)
library(kableExtra)
library(grid)
library(edgeR)
library(ggplot2)
library(reshape2)


ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
```

## Description

The genes in this pipeline are those identified to be differentially expressed (DE) in stage_I, stage_II, stage_III and stage_IV samples. Run with interaction data from DE gene list in STRING. In this run, no cutoff is used for DE genes i.e. -3 to 3 (used all DE genes).

<br> 

See end of doc for gene subset summary 

<br>

<details>

<summary>Show Kylie raw data treatment</summary>

```{r eval=FALSE}
sample_info <- read.csv("raw_data/All survival_CN_Aug18.csv")
sample_info <- subset(sample_info, select = c("GAMUT_ID", "Grade", "Stage"))

kylie_counts <- read.csv("raw_data/analysis_set_raw_counts.csv", row.names = 1)

# Extract column names
column_names <- colnames(kylie_counts)

# Remove "GAMuT_" part from column names
gamut_ids <- sub("^GAMuT_", "", column_names)


# create list of stage ids 
stage_I <- c("I","IA","IB","IC")
stage_II <- c("II", "IIA", "IIB", "IIC")
stage_III <- c("III", "IIIA", "IIIB", "IIIC", "IIIc")
stage_IV <- c("IV")
stage_ids <- list(stage_I, stage_II, stage_III, stage_IV)

# common GAMuT IDs between sample_info and kylie_counts
matching_ids <- intersect(gamut_ids, sample_info$GAMUT_ID)

stage_df <- list()

for (stage in stage_ids) {
  # sanity check
  print(stage)
  # retrieve GAMuT ID for the stage
  stage_id <- sample_info[sample_info$Stage %in% stage, 1]
  # common GAMuT IDs between stage and matching_ids
  matching_stage_id <- intersect(matching_ids, stage_id)
  # subset the kylie_counts df based on the IDs from matching_stage_id
  subset_stage_counts <- kylie_counts[, paste0("GAMuT_", matching_stage_id)]
  # add it to the df list
  stage_df <- c(stage_df, list(subset_stage_counts))
}

# retrieve each df from the list and save a separate variable
stage_I <- stage_df[[1]]
stage_II <- stage_df[[2]]
stage_III <- stage_df[[3]]
stage_IV <- as.data.frame(stage_df[[4]])
colnames(stage_IV) <- paste0("GAMuT_", matching_stage_id)
rownames(stage_IV) <- rownames(kylie_counts)


write.csv(stage_I, "rna_seq_data/stage_I_master_df.csv")
write.csv(stage_II, "rna_seq_data/stage_II_master_df.csv")
write.csv(stage_III, "rna_seq_data/stage_III_master_df.csv")
write.csv(stage_IV, "rna_seq_data/stage_IV_master_df.csv")


## subset benign samples
ben_rows <- subset(sample_info, Grade == "BEN")
ben_id <- ben_rows$GAMUT_ID
matching_ben_id <- intersect(matching_ids, ben_id)
subset_ben_counts <- kylie_counts[, paste0("GAMuT_", matching_ben_id)]

#write.csv(subset_ben_counts, "rna_seq_data/ben_master_df.csv")

#bdl_rows <- subset(sample_info, Grade == "BDL")
```

</details>

<br>

### Gene Subset Progression

<br>

-   Stage_I = 36

-   Stage_II = 2 files

-   Stage_III = 5 files

-   Stage_IV = 1 files

-   Benign = 12

<br>

<details>

<summary>Show calc + removed</summary>

```{r}
# combine stage I, II, III and IV
stage_I <- read.csv("rna_seq_data/stage_I_master_df.csv")
stage_II <- read.csv("rna_seq_data/stage_II_master_df.csv")
stage_III <- read.csv("rna_seq_data/stage_III_master_df.csv")
stage_IV <- read.csv("rna_seq_data/stage_IV_master_df.csv")

kylie_data <- merge(stage_I, stage_II, by = "X")
kylie_data <- merge(kylie_data, stage_III, by = "X")
kylie_data <- merge(kylie_data, stage_IV, by = "X")

raw_gene_list <- nrow(kylie_data)

colnames(kylie_data)[1] <- "gene_id"
gene_id <- kylie_data$gene_id
kylie_data <- kylie_data[, -1] # remove gene ids for rowSums calc

# subset genes that have a cpm of greater than one in more than 50% of the samples
keepTheseGenes <- (rowSums(cpm(kylie_data) > 1) >= ncol(kylie_data)/2)
print(summary(keepTheseGenes))

# add gene ids back into df
kylie_data <- cbind(gene_id, kylie_data)

removedGenes <- kylie_data$gene_id[!keepTheseGenes]
removedGenes <- as.data.frame(removedGenes)
colnames(removedGenes)[1] <- "gene_id"

kylie_data <- kylie_data[keepTheseGenes, ]

initial_subset <- nrow(kylie_data)
```

```{r echo=FALSE}
removed_converted <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = removedGenes$gene_id, 
                       mart = ensembl)

kable(removed_converted, format = "html", caption = "Low count genes") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
#write.csv(removed_converted, "removed_genes/rna_seq_mean_less_1.csv")
```

</details>

<br>

<br>

## Step 1: Differential expression analysis using edgeR

```{r echo=FALSE}
benign_data <- read.csv("rna_seq_data/ben_master_df.csv")
colnames(benign_data)[1] <- "gene_id"
# Get the current column names
current_names <- colnames(benign_data)
# Create new column names by replacing "GAMuT_" with "BEN_"
new_names <- sub("GAMuT_", "BEN_", current_names)
# Assign the new column names to the data frame
colnames(benign_data) <- new_names

# combine into single df
df <- inner_join(kylie_data, benign_data, by = c("gene_id"))
rownames(df) <- df$gene_id
df <- df[, -1]


# Select the columns that start with "GAMuT"
cols <- grep("^GAMuT", colnames(df))

# Assign the unstranded columns to the cancer group
cancer <- colnames(df)[cols]

# Assign the rest of the columns to the healty group
benign <- setdiff(colnames(df), cancer)

# Create the group variable
group <- factor(c(rep("cancer", length(cancer)), rep("benign", length(benign))))

data <- DGEList(counts = df, group = group)

design <- model.matrix(~group)

# Estimate a common negative binomial dispersion parameter for a DGE dataset with a general experimental design
common <- estimateGLMCommonDisp(data, design, verbose = T)

# Estimate the abundance-dispersion trend by Cox-Reid approximate profile likelihood.
trend <- estimateGLMTrendedDisp(common, design)

# Compute an empirical Bayes estimate of the negative binomial dispersion parameter for each tag, 
# with expression levels specified by a log-linear model.
tagwise <- estimateGLMTagwiseDisp(trend, design)

# Fit a negative binomial generalized log-linear model to the read counts for each gene. 
# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
fit <- glmFit(tagwise, design)

# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
lrt <- glmLRT(fit, coef = 2)

# Extract the most differentially expressed genes (or sequence tags) from a test object, 
# ranked either by p-value or by absolute log-fold-change.
toptags <- topTags(lrt, n = Inf)

# Identify which genes are significantly differentially expressed from 
# an edgeR fit object containing p-values and test statistics.
dif_exp <- decideTestsDGE(lrt, p = 0.05, adjust = "fdr", lfc = 1)
print(summary(dif_exp))

dif_exp_genes <- rownames(tagwise)[as.logical(dif_exp)]

# create a results df
hits <- toptags$table[toptags$table$FDR < 0.1, ]
colnames <- colnames(hits)
hits$gene_id <- rownames(hits)
hits <- hits[,c("gene_id", colnames)]

dif_exp <- hits[dif_exp_genes, ]

#write.csv(hits, "edgeR/edgeR_hits.csv")
#write.csv(dif_exp, "edgeR/edgeR_dif_exp_genes.csv")
```

<details>

<summary>Show non-sig diff exp genes</summary>

```{r eval=FALSE, include=FALSE}
# list of not significantly differentially expressed genes
not_sig <- as.data.frame(dif_exp)
filtered_rows <- subset(not_sig, groupcancer == 0)
not_sig <- rownames(filtered_rows)
not_sig <- as.data.frame(not_sig)


removed_converted <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = not_sig, 
                       mart = ensembl)

removed_converted <- merge(removed_converted, not_sig, by.x = "ensembl_gene_id", by.y = "not_sig", all = TRUE)

# create file for python citation script
removed_df <- subset(removed_converted, external_gene_name != "")
removed_df <- distinct(removed_df)
removed_df <- subset(removed_df, select = c("external_gene_name"))
colnames(removed_df)[1] <- "gene_id"
write.csv(removed_df, "edgeR/not_sig_dif_exp.csv")

kable(removed_converted, format = "html", caption = "Non-significantly differentially expressed genes") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

<br>

```{r echo=FALSE, out.width='33%', fig.show='hold'}
# Plot the genewise biological coefficient of variation (BCV) against gene abundance (in log2 counts per million).
plotBCV(tagwise, main = "Stage_III_IV: biological coefficient of variation")

# Make a mean-difference plot of two libraries of count data with smearing of points with very low counts, 
# especially those that are zero for one of the columns.
plotSmear(lrt, de.tags = dif_exp_genes, main = "Stage_III_IV: Mean-difference plot")

# plot Pvalues of different logFC scores
ggplot(hits, aes(x=logFC, y=-log(FDR))) + geom_point() + labs(title = "Stage_III_IV: Adjusted logFC")
```

```{r include=FALSE, eval=FALSE}
rm(list = ls()[!ls() %in% c("ensembl")])
```

<br>

## Step 2: PCSF file prep - Create score file and format STRING interaction data

-   Convert gene ensembl to gene symbol

-   Create score file from logFC values

-   Feed list of proteins into STRING/Cytoscape

-   Format output and create interaction file

<br>

<details>

<summary>Show code + removed genes</summary>

```{r}
# subset highly differentially expressed genes and create Cytoscape files

# read in the data
kylie_data <- read.csv("edgeR/edgeR_dif_exp_genes.csv")

# subset the gene_id and logFC columns
kylie_data <- subset(kylie_data, select = c("gene_id", "logFC"))

#hist(kylie_data$logFC, main = "Stage_III_IV Fold Change")


# skipped this step because subset differentially expressed genes from edgeR step

## remove all values with logFC between whatever range ya want
#kylie_data$logFC <- ifelse(kylie_data$logFC > -3 & kylie_data$logFC < 3, NA, kylie_data$logFC)
#low_logFC <- subset(kylie_data, is.na(logFC))
#kylie_data <- na.omit(kylie_data)
#
#low_logFC <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
#                       filters = "ensembl_gene_id", 
#                       values = low_logFC$gene_id, 
#                       mart = ensembl)
#
#kable(low_logFC, format = "html", caption = "Removed genes from -3 to 3 cutoff") %>%
#kable_styling(full_width = FALSE) %>%
#scroll_box(height = "400px")
```

```{r}
# convert to gene symbol
kylie_uniprot_id <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = kylie_data$gene_id, 
                       mart = ensembl)

# remove empty rows
kylie_uniprot_id <- subset(kylie_uniprot_id, external_gene_name != "") # uniprot_gn_symbol = 772

# check for duplicate uniprot ids
kylie_uniprot_id <- distinct(kylie_uniprot_id)

# merge back with original data
colnames(kylie_uniprot_id)[1] <- "gene_id"

kylie_uniprot_data <- merge(kylie_uniprot_id, kylie_data, by = "gene_id")

kylie_uniprot_data <- subset(kylie_uniprot_data, select = c("external_gene_name", "logFC"))

# check to see if genes that at all genes were converted at least once
missing_genes <- anti_join(kylie_data, kylie_uniprot_id, by = "gene_id")

# create score file
write.csv(kylie_uniprot_data, "string_run/pcsf_kylie_score.csv")
#
## create ensemble protein list for interaction db
write.table(kylie_data$external_gene_name, "string_run/kylie_gene_list.txt", row.names = F, col.names = F, quote = F)
```

```{r}
string_edge_data <- read.table("string_run/STRING network (physical) default edge.csv", header = T, sep = ",", stringsAsFactors = F)
ppi_list <- subset(string_edge_data, select = c("name", "stringdb..score"))
ppi_list <- ppi_list %>% 
  separate(name, sep = " ", into = c("node_1", "del", "node_2"))
ppi_list <- subset(ppi_list, select = c("node_1", "node_2", "stringdb..score"))
ppi_list$node_1 <- gsub(".*.\\.", "", ppi_list$node_1)
ppi_list$node_2 <- gsub(".*.\\.", "", ppi_list$node_2)

string_node_data <- read.table("string_run/STRING network (physical) default node.csv", header = T, sep = ",", stringsAsFactors = F)
node_list <- subset(string_node_data, select = c("name", "query.term"))
node_list$name <- gsub(".*.\\.", "", node_list$name)
ppi_list$original_order <- seq_len(nrow(ppi_list))
merged_df <- merge(ppi_list, node_list, by.x = "node_1", by.y = "name", all.x = TRUE)
merged_df <- merge(merged_df, node_list, by.x = "node_2", by.y = "name", all.x = TRUE)
merged_df <- merged_df[order(merged_df$original_order), ]

final_df <- merged_df[, c("query.term.x", "query.term.y", "stringdb..score")]
colnames(final_df) <- c("node_1", "node_2", "score")

write.csv(final_df, "string_run/interaction_score.csv")


# create gene_id uniprot_id ref list.
ref_list <- getBM(attributes = c("external_gene_name","uniprot_gn_id"),
                  filters = "external_gene_name", 
                  values = node_list$query.term, 
                  mart = ensembl)


write.table(ref_list$external_gene_name, "string_run/string_gene_names.csv", quote = F, row.names = F, col.names = F)
```

</details>

<br>

## Step 3: Run PCSF and create cross reference results with AF structures for durggability

```{r echo=FALSE}
# set seed for reproducibility 
set.seed(1234)

# read in STRING data
kylie_string_data <- read.csv("string_run/interaction_score.csv", row.names = 1)

# construct interactome
kylie_ppi <- construct_interactome(kylie_string_data)

# read in score file
kylie_data <- read.csv("string_run/pcsf_kylie_score.csv", row.names = 1)

# set terminals
kylie_terminals <- setNames(as.numeric(kylie_data$logFC), kylie_data$external_gene_name)

# run PCSF with random noise

# time a pcsf run
start_time <- Sys.time()
kylie_subnet <- PCSF_rand(kylie_ppi, kylie_terminals, n = 50, r = 0.1, w = 2, b = 1, mu = 0.0005)
elapsed_time <- Sys.time() - start_time
print(elapsed_time)

plot.PCSF(kylie_subnet, node_label_cex = 15)
```

<br>

```{r include=FALSE}
# extract cluster data
kylie_clust <- clusters(kylie_subnet)
kylie_df <- data.frame(gene_id = names(kylie_clust$membership), cluster = factor(kylie_clust$membership))
kylie_betweenness <- betweenness(kylie_subnet) 
kylie_centrality <- degree(kylie_subnet) 
kylie_df$betweenness <- kylie_betweenness[as.character(kylie_df$gene_id)]
kylie_df$degree_centrality <- kylie_centrality[as.character(kylie_df$gene_id)]
kylie_df$betweenness <- as.integer(kylie_df$betweenness)
kylie_df$degree_centrality <- as.integer(kylie_df$degree_centrality)

rownames(kylie_df) <- 1:nrow(kylie_df)

kylie_df <- kylie_df[order(kylie_df$cluster), ]

write.csv(kylie_df, "string_run/kylie_pcsf_results.csv", row.names = F)
```

```{r, include=FALSE}
# read in data
af_drugability <- read.csv("fpocket_druggability.csv")
kylie_pcsf <- read.csv("string_run/kylie_pcsf_results.csv")
kylie_pcsf <- merge(ref_list, kylie_pcsf, by.x = "external_gene_name", by.y = "gene_id")

# merge AF data with PCSF data by uniprot ID
kylie_pcsf_master <- merge(kylie_pcsf, af_drugability, by.x = "uniprot_gn_id", by.y = "uniprot_id")
kylie_pcsf_master <- subset(kylie_pcsf_master, select = c("external_gene_name", "uniprot_gn_id", "ID", "cluster", 
                                                          "betweenness", "degree_centrality", "pocket", 
                                                          "druggability", "num_drug_pockets", "struct_score"))

kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]

druggability_crossref <- nrow(kylie_pcsf_master)

kylie_pcsf_master <- distinct(kylie_pcsf_master)

write.csv(kylie_pcsf_master, "string_run/kylie_PCSF_drugability.csv")
```

Note: The citation scores for this data were generated outside this R script using PubMed API

```{r echo=FALSE}
# add up and down regulaiton tags to table
up_or_down <- read.csv("string_run/pcsf_kylie_score.csv", row.names = 1)
up_or_down$regulation <- ifelse(up_or_down$logFC > 0, "up_reg", "dn_reg")
colnames(up_or_down)[1] <- "gene_id"
kylie_pcsf_master <- read.csv("string_run/kylie_PCSF_drugability.csv", row.names = 1)
kylie_pcsf_master <- merge(kylie_pcsf_master, up_or_down, by.x = "external_gene_name", by.y = "gene_id")

# run the citation score script now using kylie_PCSF_drugability.csv

# add citation scores
cit_scores <- read.csv("string_run/citation_scores.csv")
kylie_pcsf_master <- merge(kylie_pcsf_master, cit_scores, by.x = "external_gene_name", by.y = "gene_id")

# keeping logFC now
#kylie_pcsf_master <- subset(kylie_pcsf_master, select = c("ensembl_gene_id", "external_gene_name", 
#                                                          "uniprot_id", "cluster", "betweenness",
#                                                          "degree_centrality", "pocket", "druggability",
#                                                          "num_drug_pockets", "struct_score", "regulation",
#                                                          "citation_score"))


kylie_pcsf_master <- distinct(kylie_pcsf_master)
kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]
rownames(kylie_pcsf_master) <- NULL

# remove duplicates
master_unique <- kylie_pcsf_master[!duplicated(kylie_pcsf_master$external_gene_name), ]
rownames(master_unique) <- NULL

write.csv(kylie_pcsf_master, "string_run/kylie_pcsf_master.csv")
```

<details>

<summary>Show raw table</summary>

```{r echo=FALSE}
kable(kylie_pcsf_master, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

Note: Duplicates removed here

```{r echo=FALSE}
kable(master_unique, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<details>

```{r eval=FALSE}
# dont need it, doenst work

subset_genes <- as.data.frame(kylie_pcsf_master$gene_id)
colnames(subset_genes)[1] <- "gene_id"

network_out_genes <- anti_join(kylie_uniprot_id, subset_genes, by = "gene_id")

kable(network_out_genes, format = "html", caption = "Removed genes from cytoscape + network + druggability filters") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

## Step 4: Functional Enrichment Analysis

<details>

<summary>Show code</summary>

```{r echo=FALSE}
enrichment_analysis_edit <-function(subnet, mode=NULL, gene_universe){
  
  # Checking function arguments
  if (missing(subnet))
    stop("Need to specify the subnetwork obtained from the PCSF algorithm.")
  if (class(subnet)[1] != "PCSF" || class(subnet)[2] != "igraph")
    stop("The subnetwork must be a \"PCSF\" object derived from an \"igraph\" class.")
  if (!is.null(mode)){
    if(mode==1 && missing(gene_universe))
      stop("Need to specify a list of genes (vector of gene symbols) used as background in enrichment analysis by topGO package")
  }
  
  
  cat("  Performing enrichment analysis...\n\n")
  
  # Obtain clusters in the subnet using edge betweenness clustering algorithm from igraph package.
  clusters = cluster_edge_betweenness(subnet)
  
  # Perform ebrichment analysis for each cluster using EnrichR through its API or topGO.
  #print("Performing enrichment analysis...")
  #print(paste("Number of clusters:", length(clusters$membership)))
  
  havingInternet <- function() {
    if (.Platform$OS.type == "windows") {
      ipmessage <- system("ipconfig", intern = TRUE)
    } else {
      ipmessage <- system("ifconfig", intern = TRUE)
    }
    validIP <- "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)[.]){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    any(grep(validIP, ipmessage))
  }
  
  internet_connection <- havingInternet()
  
  if(!is.null(mode)){
    if(mode==0){
      if(internet_connection){
        cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
        enrich = call_enr(clusters, mode = 0, gene_universe)
      }
      else{
        stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
      }
    }
    else{
      cat("  Enrichment is being performed by topGO package ...\n")
      enrich = call_enr(clusters, mode = mode, gene_universe)
    }
  }
  else
  {
    if(internet_connection){
      cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
      enrich = call_enr(clusters, mode = 0, gene_universe)
    }
    else{
      stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
    }
  }
  
  if('Compound'%in% V(subnet)$type){##then we have drugs!
    require(dplyr)
    comps=data.frame(Drug=V(subnet)$name[which(V(subnet)$type=='Compound')],
                     Cluster=clusters$membership[which(V(subnet)$type=='Compound')])%>%
      dplyr::group_by(Cluster)%>%
      dplyr::summarise(DrugsByBetweenness=paste(Drug,collapse=';'))
    
  }
  else{
    comps <-NULL
  }
  enrichment = enrich[[1]]
  enrichment_complete = enrich[[2]]
  print(paste("Number of enrichment results:", length(enrichment_complete)))
  
  #for (x in 1:length(enrichment_complete)) {
  #  print(paste("Cluster", x, "enrichment complete:", enrichment_complete[[x]]))
  #}
  
  novals<-which(unlist(sapply(enrich[[2]],function(x) is.null(dim(x)))))
  if(length(novals)>0)
    enrichment_complete <- enrichment_complete[-novals]
  
  enrichment_tab <- do.call(rbind, lapply(seq_along(enrichment_complete), function(x) {
    if (!is.null(dim(enrichment_complete[[x]]))) {
      data.frame(Cluster = x, enrichment_complete[[x]])
    } else {
      NULL
    }
  }))
  
  more.than.two <- which(sapply(enrichment_tab$Genes, function(x) length(unlist(strsplit(x, split = ';')))) > 2)
  if (length(more.than.two) > 0)
    enrichment_tab <- enrichment_tab[more.than.two, ]
  
  if(!is.null(comps))
    enrichment_tab = enrichment_tab%>%dplyr::left_join(comps,by='Cluster')
  
  # Add 'group" and 'title' attributes to subnet
  V(subnet)$group = clusters$membership
  V(subnet)$title = paste0("Cluster ",clusters$membership,": Enrichment analysis")
  for( i in 1:length(V(subnet))){
    V(subnet)$title[i] = paste0( V(subnet)$title[i], enrichment[[V(subnet)$group[i]]])
  }
  
  # Derive a "PCSFe" object from an "igraph" class.
  class(subnet) <- c("PCSFe", "igraph")
  # Combine the subnetwork and colplete enrichment analysis tables.
  output = list(subnet, enrichment_tab)
  names(output) = c("subnet", "enrichment")
  
  return (output)
}

# functional enrichment using enrichR
res <- enrichment_analysis_edit(kylie_subnet)
```

</details>

<br>

#### Tip: Hover over nodes for details!

```{r echo=FALSE}
plot.PCSFe(res$subnet, edge_width = 8, node_size = 30, node_label_cex = 1)
```

<br>

Note: P-value represents likelihood of observing that pathway by random chance. The top 15 functional enrichment terms for each cluster are ranked according to the adjusted p-value. This is what you observe when you hover your mouse over a node in that cluster.

<br>

```{r include=FALSE}
enrichment_results <- res$enrichment

# Create a data frame with the enrichment results
enrichment_table <- data.frame(
  Cluster = enrichment_results$Cluster,
  Term = enrichment_results$Term,
  PValue = enrichment_results$P.value,
  Adjusted_Pvalue = enrichment_results$Adjusted.P.value,
  Genes = enrichment_results$Genes)

write.csv(enrichment_table, "string_run/enrichment_results.csv")
```

#### Tabulated format

```{r echo=FALSE}
enrichment_table <- read.csv("string_run/enrichment_results.csv", row.names = 1)
  
kable(enrichment_table, format = "html", caption = "Enrichment Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<br>

In this table the genes are ordered by their combined rank score which is a normalised score with the following contributions.

<br>

-   Betweeness: 10%
-   Citation score: 20%
-   Degree centrality: 30%
-   Druggability: 40%

<br>

```{r echo=FALSE}
# normalize scores for overall rank
# double check to 

kylie_pcsf_master <- read.csv("string_run/kylie_pcsf_master.csv", row.names = 1)

betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

# Custom weights
betweeness_w <- 0.10
citation_w <- 0.20
centrality_w <- 0.30
druggability_w <- 0.40


# Combine scores using custom weights
combined_score <- betweeness_w * betweeness_norm +
  centrality_w * centrality_norm +
  druggability_w * kylie_pcsf_master$druggability -
  citation_w * citation_norm

kylie_pcsf_master_edit <- cbind(kylie_pcsf_master, combined_score)

kylie_pcsf_master_edit <- kylie_pcsf_master_edit[order(-kylie_pcsf_master_edit$combined_score), ]

kylie_pcsf_master_edit_unique <- kylie_pcsf_master_edit[!duplicated(kylie_pcsf_master_edit$external_gene_name), ]

rownames(kylie_pcsf_master_edit) <- NULL

kable(kylie_pcsf_master_edit, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<details>

<summary>Show unique genes only</summary>

```{r}
kable(kylie_pcsf_master_edit_unique, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

<br>

```{r echo=FALSE, eval=FALSE}
# all this is wrong, figure out how to compare enrichment to the original network to see which genes are different

network_genes <- as.data.frame(V(kylie_subnet)$name)
colnames(network_genes)[1] <- "external_gene_name"

enrichment_genes <- res$enrichment$Genes
enrichment_genes <- strsplit(enrichment_genes, ";")
enrichment_genes <- unlist(enrichment_genes)
enrichment_genes <- as.data.frame(trimws(enrichment_genes))
colnames(enrichment_genes)[1] <- "external_gene_name"

network_out_genes <- anti_join(network_genes, enrichment_genes, by = "external_gene_name")

kable(network_out_genes, format = "html", caption = "Removed genes from cytoscape + network + druggability filters") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

### Gene subset progression

<br>

```{r echo=FALSE}
edgeR_hits_dif_exp <- nrow(dif_exp)
ensembl_gene_converted <- nrow(kylie_uniprot_id)
cytoscape_string <- nrow(node_list)
pcsf_subnet <- length(kylie_subnet)
unique_ids <- nrow(kylie_pcsf_master_edit_unique)

# create summary
cat(paste("Raw gene list =", raw_gene_list, "--> Initial subset (>1 in >=0.5) =", initial_subset))
cat(paste("Initial subset =", initial_subset, "--> EdgeR hits (only dif exp genes) =", edgeR_hits_dif_exp))
cat(paste("EdgeR hits =", edgeR_hits_dif_exp, "--> ensembl gene converted =", ensembl_gene_converted))
cat(paste("ensembl gene converted =", ensembl_gene_converted, "--> Cytoscape/STRING =", cytoscape_string))
cat(paste("Cytoscape/STRING =", cytoscape_string, "--> PCSF subnet =", pcsf_subnet))
cat(paste("PCSF subnet =", pcsf_subnet, "--> Druggability CrossRef =", druggability_crossref))
cat(paste("Druggability CrossRef =", druggability_crossref, "--> Unique IDs =", unique_ids))
```

<br>

<br>

end of doc