---
title: "MOC PCSF Pipeline"
output: html_document
date: "2023-11-16"
---

```{r load packages, include=FALSE}
library(PCSF)
library(plyr)
library(biomaRt)
library(dplyr)
library(tidyr)
library(kableExtra)
library(grid)
library(edgeR)
library(ggplot2)
library(reshape2)
library(progress)
library(RobustRankAggreg)


ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
```

## Description

The genes in this pipeline are those identified to be differentially expressed (DE) in stage_I, stage_II, stage_III and stage_IV samples. Run with interaction data from DE gene list in STRING. In this run, no cutoff is used for DE genes i.e. -3 to 3 (used all DE genes).

<br> 

See end of doc for gene subset summary 

<br>

<details>

<summary>Show Kylie raw data treatment</summary>

```{r seperate based on stage, eval=FALSE}
sample_info <- read.csv("data/All survival_CN_Aug18.csv")
sample_info <- subset(sample_info, select = c("GAMUT_ID", "Grade", "Stage"))

kylie_counts <- read.csv("data/analysis_set_raw_counts.csv", row.names = 1)

# Extract column names
column_names <- colnames(kylie_counts)

# Remove "GAMuT_" part from column names
gamut_ids <- sub("^GAMuT_", "", column_names)


# create list of stage ids 
stage_I <- c("I","IA","IB","IC")
stage_II <- c("II", "IIA", "IIB", "IIC")
stage_III <- c("III", "IIIA", "IIIB", "IIIC", "IIIc")
stage_IV <- c("IV")
stage_ids <- list(stage_I, stage_II, stage_III, stage_IV)

# common GAMuT IDs between sample_info and kylie_counts
matching_ids <- intersect(gamut_ids, sample_info$GAMUT_ID)

stage_df <- list()

for (stage in stage_ids) {
  # sanity check
  print(stage)
  # retrieve GAMuT ID for the stage
  stage_id <- sample_info[sample_info$Stage %in% stage, 1]
  # common GAMuT IDs between stage and matching_ids
  matching_stage_id <- intersect(matching_ids, stage_id)
  # subset the kylie_counts df based on the IDs from matching_stage_id
  subset_stage_counts <- kylie_counts[, paste0("GAMuT_", matching_stage_id)]
  # add it to the df list
  stage_df <- c(stage_df, list(subset_stage_counts))
}

# retrieve each df from the list and save a separate variable
stage_I <- stage_df[[1]]
stage_II <- stage_df[[2]]
stage_III <- stage_df[[3]]
stage_IV <- as.data.frame(stage_df[[4]])
colnames(stage_IV) <- paste0("GAMuT_", matching_stage_id)
rownames(stage_IV) <- rownames(kylie_counts)


write.csv(stage_I, "data/stage_I_master_df.csv")
write.csv(stage_II, "data/stage_II_master_df.csv")
write.csv(stage_III, "data/stage_III_master_df.csv")
write.csv(stage_IV, "data/stage_IV_master_df.csv")


## subset benign samples
ben_rows <- subset(sample_info, Grade == "BEN")
ben_id <- ben_rows$GAMUT_ID
matching_ben_id <- intersect(matching_ids, ben_id)
subset_ben_counts <- kylie_counts[, paste0("GAMuT_", matching_ben_id)]

write.csv(subset_ben_counts, "data/ben_master_df.csv")

#bdl_rows <- subset(sample_info, Grade == "BDL")
```

</details>

<br>

### Gene Subset Progression

The raw data consists of 14,889 genes which was subject to removal of low acitvity genes by subsetting those that have a CPM of more than 1 in at least 50% of the samples.

<br>

-   Stage_I = 36

-   Stage_II = 2 files

-   Stage_III = 5 files

-   Stage_IV = 1 files

-   Benign = 11

<br>

FALSE = Failed genes
```{r remove low activity genes, echo=FALSE}
# combine stage I, II, III and IV
stage_I <- read.csv("data/stage_I_master_df.csv")
stage_II <- read.csv("data/stage_II_master_df.csv")
stage_III <- read.csv("data/stage_III_master_df.csv")
stage_IV <- read.csv("data/stage_IV_master_df.csv")

# merge disease groups together
kylie_data <- merge(stage_I, stage_II, by = "X")
kylie_data <- merge(kylie_data, stage_III, by = "X")
kylie_data <- merge(kylie_data, stage_IV, by = "X")

colnames(kylie_data)[1] <- "gene_id"

benign_data <- read.csv("data/ben_master_df.csv")
colnames(benign_data)[1] <- "gene_id"
# Get the current column names
current_names <- colnames(benign_data)
# Create new column names by replacing "GAMuT_" with "BEN_"
new_names <- sub("GAMuT_", "BEN_", current_names)
# Assign the new column names to the data frame
colnames(benign_data) <- new_names

# combine into single df
df <- inner_join(kylie_data, benign_data, by = c("gene_id"))
rownames(df) <- df$gene_id
df <- df[, -1]
raw_gene_list <- nrow(kylie_data)

gene_id <- rownames(df)
#kylie_data <- kylie_data[, -1] # remove gene ids for rowSums calc

# subset genes that have a cpm of greater than one in more than 50% of the samples
keepTheseGenes <- (rowSums(cpm(df) > 1) >= ncol(df)/2)
print(summary(keepTheseGenes))

# add gene ids back into df
#df <- cbind(gene_id, df)

removedGenes <- rownames(df)[!keepTheseGenes]
removedGenes <- as.data.frame(removedGenes)
colnames(removedGenes)[1] <- "gene_id"

df <- df[keepTheseGenes, ]

initial_subset <- nrow(df)
```

<details>

<summary>Show low acitivty genes</summary>
```{r low activity genes, echo=FALSE}
removed_converted <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = removedGenes$gene_id, 
                       mart = ensembl)

kable(removed_converted, format = "html", caption = "Low count genes") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

<br>

<br>

## Step 1: Differential expression analysis using edgeR

```{r differential expression, echo=FALSE, warning=FALSE}
# Select the columns that start with "GAMuT"
cols <- grep("^GAMuT", colnames(df))

# Assign the unstranded columns to the cancer group
cancer <- colnames(df)[cols]

# Assign the rest of the columns to the healty group
benign <- setdiff(colnames(df), cancer)

# Create the group variable
group <- factor(c(rep("cancer", length(cancer)), rep("benign", length(benign))))

data <- DGEList(counts = df, group = group)

design <- model.matrix(~group)

# Estimate a common negative binomial dispersion parameter for a DGE dataset with a general experimental design
common <- estimateGLMCommonDisp(data, design, verbose = T)

# Estimate the abundance-dispersion trend by Cox-Reid approximate profile likelihood.
trend <- estimateGLMTrendedDisp(common, design)

# Compute an empirical Bayes estimate of the negative binomial dispersion parameter for each tag, 
# with expression levels specified by a log-linear model.
tagwise <- estimateGLMTagwiseDisp(trend, design)

# Fit a negative binomial generalized log-linear model to the read counts for each gene. 
# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
fit <- glmFit(tagwise, design)

# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
lrt <- glmLRT(fit, coef = 2)

# Extract the most differentially expressed genes (or sequence tags) from a test object, 
# ranked either by p-value or by absolute log-fold-change.
toptags <- topTags(lrt, n = Inf)

# Identify which genes are significantly differentially expressed from 
# an edgeR fit object containing p-values and test statistics.
dif_exp <- decideTestsDGE(lrt, p = 0.05, adjust = "fdr", lfc = 1)
print(summary(dif_exp))

dif_exp_genes <- rownames(tagwise)[as.logical(dif_exp)]

# create a results df
hits <- toptags$table[toptags$table$FDR < 0.1, ]
colnames <- colnames(hits)
hits$gene_id <- rownames(hits)
hits <- hits[,c("gene_id", colnames)]

dif_exp <- hits[dif_exp_genes, ]

non_dif_exp_genes <- hits[hits$gene_id != dif_exp_genes, ]

write.csv(hits, "intermediate/edgeR/edgeR_hits.csv")
write.csv(dif_exp, "intermediate/edgeR/edgeR_dif_exp_genes.csv")
write.csv(non_dif_exp_genes, "intermediate/edgeR/non_dif_exp_genes.csv")
```
<br>

```{r plot DE data, echo=FALSE, out.width='33%', fig.show='hold'}
# Plot the genewise biological coefficient of variation (BCV) against gene abundance (in log2 counts per million).
plotBCV(tagwise, main = "Biological coefficient of variation")

# Make a mean-difference plot of two libraries of count data with smearing of points with very low counts, 
# especially those that are zero for one of the columns.
plotSmear(lrt, de.tags = dif_exp_genes, main = "Mean-difference plot")

# plot Pvalues of different logFC scores
ggplot(hits, aes(x=logFC, y=-log(FDR))) + geom_point() + labs(title = "Adjusted logFC")
```

```{r include=FALSE, eval=FALSE}
rm(list = ls()[!ls() %in% c("ensembl")])
```

<br>

## Step 2: PCSF file prep - Create score file and format STRING interaction data

-   Convert gene ensembl to gene symbol

-   Create score file from logFC values

-   Feed list of proteins into STRING/Cytoscape

-   Format output and create interaction file

<br>

<details>

<summary>Show code</summary>

```{r PCSF score file}
## convert to gene names and create list for STRING

# read in the data
kylie_data <- read.csv("intermediate/edgeR/edgeR_dif_exp_genes.csv")

# subset the gene_id and logFC columns
kylie_data <- subset(kylie_data, select = c("gene_id", "logFC"))

# convert to gene symbol
gene_id <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = kylie_data$gene_id, 
                       mart = ensembl)

# remove empty rows
gene_id <- subset(gene_id, external_gene_name != "") # uniprot_gn_symbol = 772

# check for duplicate uniprot ids
gene_id <- distinct(gene_id)

# merge back with original data
colnames(gene_id)[1] <- "gene_id"

kylie_gene_data <- merge(gene_id, kylie_data, by = "gene_id")

kylie_gene_data <- subset(kylie_gene_data, select = c("external_gene_name", "logFC"))

# check to see if genes that at all genes were converted at least once
missing_genes <- anti_join(kylie_data, gene_id, by = "gene_id")

# create score file
write.csv(kylie_gene_data, "intermediate/PCSF_data/pcsf_kylie_score.csv")

## create ensemble protein list for interaction db
write.table(kylie_gene_data$external_gene_name, "intermediate/cytoscape/kylie_gene_list.txt", row.names = F, col.names = F, quote = F)
```

```{r format STRING output}
string_edge_data <- read.table("intermediate/cytoscape/STRING network (physical) default edge.csv", header = T, sep = ",", stringsAsFactors = F)
ppi_list <- subset(string_edge_data, select = c("name", "stringdb..score"))
ppi_list <- ppi_list %>% 
  separate(name, sep = " ", into = c("node_1", "del", "node_2"))
ppi_list <- subset(ppi_list, select = c("node_1", "node_2", "stringdb..score"))
ppi_list$node_1 <- gsub(".*.\\.", "", ppi_list$node_1)
ppi_list$node_2 <- gsub(".*.\\.", "", ppi_list$node_2)

string_node_data <- read.table("intermediate/cytoscape/STRING network (physical) default node.csv", header = T, sep = ",", stringsAsFactors = F)
node_list <- subset(string_node_data, select = c("name", "query.term"))
node_list$name <- gsub(".*.\\.", "", node_list$name)
ppi_list$original_order <- seq_len(nrow(ppi_list))
merged_df <- merge(ppi_list, node_list, by.x = "node_1", by.y = "name", all.x = TRUE)
merged_df <- merge(merged_df, node_list, by.x = "node_2", by.y = "name", all.x = TRUE)
merged_df <- merged_df[order(merged_df$original_order), ]

final_df <- merged_df[, c("query.term.x", "query.term.y", "stringdb..score")]
colnames(final_df) <- c("node_1", "node_2", "score")

write.csv(final_df, "intermediate/PCSF_data/STRING_data.csv")


# create gene_id uniprot_id ref list.
ref_list <- getBM(attributes = c("external_gene_name","uniprot_gn_id"),
                  filters = "external_gene_name", 
                  values = node_list$query.term, 
                  mart = ensembl)
```

</details>

<br>

## Step 3: Run PCSF and create cross reference results with AF structures for durggability

```{r run PCSF, echo=FALSE}
# set seed for reproducibility 
set.seed(1234)

# read in STRING data
#kylie_string_data <- read.csv("string_run/interaction_score.csv", row.names = 1)

# construct interactome
kylie_ppi <- construct_interactome(final_df)

# read in score file
#kylie_data <- read.csv("string_run/pcsf_kylie_score.csv", row.names = 1)

# set terminals
kylie_terminals <- setNames(as.numeric(kylie_gene_data$logFC), kylie_gene_data$external_gene_name)

# run PCSF with random noise

# time a pcsf run
start_time <- Sys.time()
kylie_subnet <- PCSF_rand(kylie_ppi, kylie_terminals, n = 50, r = 0.1, w = 2, b = 1, mu = 0.0005)
elapsed_time <- Sys.time() - start_time
print(elapsed_time)

plot.PCSF(kylie_subnet, node_label_cex = 15)
```

<br>

```{r extract network metrics, include=FALSE}
# extract cluster data
kylie_clust <- clusters(kylie_subnet)
kylie_df <- data.frame(gene_id = names(kylie_clust$membership), cluster = factor(kylie_clust$membership))
kylie_betweenness <- betweenness(kylie_subnet) 
kylie_centrality <- degree(kylie_subnet) 
kylie_df$betweenness <- kylie_betweenness[as.character(kylie_df$gene_id)]
kylie_df$degree_centrality <- kylie_centrality[as.character(kylie_df$gene_id)]
kylie_df$betweenness <- as.integer(kylie_df$betweenness)
kylie_df$degree_centrality <- as.integer(kylie_df$degree_centrality)

rownames(kylie_df) <- 1:nrow(kylie_df)

kylie_df <- kylie_df[order(kylie_df$cluster), ]

write.csv(kylie_df, "results/PCSF_results.csv", row.names = F)
```

```{r tabulate PCSF data, echo=FALSE}
kylie_df <- kylie_df[order(kylie_df$degree_centrality), ]

kable(kylie_df, format = "html", caption = "PCSF Nertwork Metrics") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

<br>

## Step 4: Combine Structural and Citation data
```{r add fpocket data, include=FALSE}
# read in data
af_drugability <- read.csv("../../../druggability_results/fpocket_druggability.csv")
kylie_pcsf <- read.csv("results/PCSF_results.csv")
kylie_pcsf <- merge(ref_list, kylie_pcsf, by.x = "external_gene_name", by.y = "gene_id")

# merge AF data with PCSF data by uniprot ID
kylie_pcsf_master <- merge(kylie_pcsf, af_drugability, by.x = "uniprot_gn_id", by.y = "uniprot_id")

kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]

druggability_crossref <- nrow(kylie_pcsf_master)

write.csv(kylie_pcsf_master, "results/MOC_PCSF_drugability.csv")
```

Note: The citation scores for this data were generated using PubMed API

```{r add up/down reg, echo=FALSE}
# add up and down regulaiton tags to table
up_or_down <- read.csv("intermediate/PCSF_data/pcsf_kylie_score.csv", row.names = 1)
up_or_down$regulation <- ifelse(up_or_down$logFC > 0, "up_reg", "dn_reg")
colnames(up_or_down)[1] <- "gene_id"
kylie_pcsf_master <- read.csv("results/MOC_PCSF_drugability.csv", row.names = 1)
kylie_pcsf_master <- merge(kylie_pcsf_master, up_or_down, by.x = "external_gene_name", by.y = "gene_id")
```

```{r add citation scores, echo=FALSE}
# run the citation score script now using kylie_PCSF_druggability.csv

# add citation scores
cit_scores <- read.csv("intermediate/citation_scores.csv")
kylie_pcsf_master <- merge(kylie_pcsf_master, cit_scores, by.x = "external_gene_name", by.y = "gene_id")

kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]
rownames(kylie_pcsf_master) <- NULL

# remove duplicates
master_unique <- kylie_pcsf_master[!duplicated(kylie_pcsf_master$external_gene_name), ]

rownames(master_unique) <- NULL

write.csv(kylie_pcsf_master, "results/MOC_PCSF_master.csv")
write.csv(master_unique, "results/MOC_PCSF_master_unique.csv")
```

<details>

<summary>Show raw table</summary>

```{r tabulate data, echo=FALSE}
kable(kylie_pcsf_master, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

```{r tabulate unique data, echo=FALSE}
kable(master_unique, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

## Step 5: Functional Enrichment Analysis

<details>

<summary>Show code</summary>

```{r enrichment, echo=FALSE}
enrichment_analysis_edit <-function(subnet, mode=NULL, gene_universe){
  
  # Checking function arguments
  if (missing(subnet))
    stop("Need to specify the subnetwork obtained from the PCSF algorithm.")
  if (class(subnet)[1] != "PCSF" || class(subnet)[2] != "igraph")
    stop("The subnetwork must be a \"PCSF\" object derived from an \"igraph\" class.")
  if (!is.null(mode)){
    if(mode==1 && missing(gene_universe))
      stop("Need to specify a list of genes (vector of gene symbols) used as background in enrichment analysis by topGO package")
  }
  
  
  cat("  Performing enrichment analysis...\n\n")
  
  # Obtain clusters in the subnet using edge betweenness clustering algorithm from igraph package.
  clusters = cluster_edge_betweenness(subnet)
  
  # Perform ebrichment analysis for each cluster using EnrichR through its API or topGO.
  #print("Performing enrichment analysis...")
  #print(paste("Number of clusters:", length(clusters$membership)))
  
  havingInternet <- function() {
    if (.Platform$OS.type == "windows") {
      ipmessage <- system("ipconfig", intern = TRUE)
    } else {
      ipmessage <- system("ifconfig", intern = TRUE)
    }
    validIP <- "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)[.]){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    any(grep(validIP, ipmessage))
  }
  
  internet_connection <- havingInternet()
  
  if(!is.null(mode)){
    if(mode==0){
      if(internet_connection){
        cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
        enrich = call_enr(clusters, mode = 0, gene_universe)
      }
      else{
        stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
      }
    }
    else{
      cat("  Enrichment is being performed by topGO package ...\n")
      enrich = call_enr(clusters, mode = mode, gene_universe)
    }
  }
  else
  {
    if(internet_connection){
      cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
      enrich = call_enr(clusters, mode = 0, gene_universe)
    }
    else{
      stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
    }
  }
  
  if('Compound'%in% V(subnet)$type){##then we have drugs!
    require(dplyr)
    comps=data.frame(Drug=V(subnet)$name[which(V(subnet)$type=='Compound')],
                     Cluster=clusters$membership[which(V(subnet)$type=='Compound')])%>%
      dplyr::group_by(Cluster)%>%
      dplyr::summarise(DrugsByBetweenness=paste(Drug,collapse=';'))
    
  }
  else{
    comps <-NULL
  }
  enrichment = enrich[[1]]
  enrichment_complete = enrich[[2]]
  print(paste("Number of enrichment results:", length(enrichment_complete)))
  
  #for (x in 1:length(enrichment_complete)) {
  #  print(paste("Cluster", x, "enrichment complete:", enrichment_complete[[x]]))
  #}
  
  novals<-which(unlist(sapply(enrich[[2]],function(x) is.null(dim(x)))))
  if(length(novals)>0)
    enrichment_complete <- enrichment_complete[-novals]
  
  enrichment_tab <- do.call(rbind, lapply(seq_along(enrichment_complete), function(x) {
    if (!is.null(dim(enrichment_complete[[x]]))) {
      data.frame(Cluster = x, enrichment_complete[[x]])
    } else {
      NULL
    }
  }))
  
  more.than.two <- which(sapply(enrichment_tab$Genes, function(x) length(unlist(strsplit(x, split = ';')))) > 2)
  if (length(more.than.two) > 0)
    enrichment_tab <- enrichment_tab[more.than.two, ]
  
  if(!is.null(comps))
    enrichment_tab = enrichment_tab%>%dplyr::left_join(comps,by='Cluster')
  
  # Add 'group" and 'title' attributes to subnet
  V(subnet)$group = clusters$membership
  V(subnet)$title = paste0("Cluster ",clusters$membership,": Enrichment analysis")
  for( i in 1:length(V(subnet))){
    V(subnet)$title[i] = paste0( V(subnet)$title[i], enrichment[[V(subnet)$group[i]]])
  }
  
  # Derive a "PCSFe" object from an "igraph" class.
  class(subnet) <- c("PCSFe", "igraph")
  # Combine the subnetwork and colplete enrichment analysis tables.
  output = list(subnet, enrichment_tab)
  names(output) = c("subnet", "enrichment")
  
  return (output)
}

# functional enrichment using enrichR
res <- enrichment_analysis_edit(kylie_subnet)
```

</details>

<br>

#### Tip: Hover over nodes for details!

```{r plot enrichment, echo=FALSE}
plot.PCSFe(res$subnet, edge_width = 8, node_size = 30, node_label_cex = 1)
```

<br>

Note: P-value represents likelihood of observing that pathway by random chance. The top 15 functional enrichment terms for each cluster are ranked according to the adjusted p-value. This is what you observe when you hover your mouse over a node in that cluster.

<br>

```{r extarct enrichment data, include=FALSE}
enrichment_results <- res$enrichment

# Create a data frame with the enrichment results
enrichment_table <- data.frame(
  Cluster = enrichment_results$Cluster,
  Term = enrichment_results$Term,
  PValue = enrichment_results$P.value,
  Adjusted_Pvalue = enrichment_results$Adjusted.P.value,
  Genes = enrichment_results$Genes)

write.csv(enrichment_table, "results/enrichR_results.csv")
```

<details>

<summary>Tabulated format</summary>

```{r tabulate enrichment, echo=FALSE}
kable(enrichment_table, format = "html", caption = "Enrichment Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

<br>

<br>

## Weighted Gene Ranking

In this table the genes are ordered by their combined rank score which is a normalised score with the following contributions:

-   Betweeness: 10%
-   Citation score: 20%
-   Degree centrality: 30%
-   Druggability: 40%

<br>

```{r apply custom weights, echo=FALSE}
# normalize scores for overall rank
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

# Custom weights
betweeness_w <- 0.10
citation_w <- 0.20
centrality_w <- 0.30
druggability_w <- 0.40


# Combine scores using custom weights
combined_score <- betweeness_w * betweeness_norm +
  centrality_w * centrality_norm +
  druggability_w * kylie_pcsf_master$druggability -
  citation_w * citation_norm

kylie_pcsf_master_ranked <- cbind(kylie_pcsf_master, combined_score)

kylie_pcsf_master_ranked <- kylie_pcsf_master_ranked[order(-kylie_pcsf_master_ranked$combined_score), ]

rownames(kylie_pcsf_master_ranked) <- NULL

kable(kylie_pcsf_master_ranked, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

<br>

### Gene subset progression

<br>

```{r data summary, echo=FALSE}
edgeR_hits_dif_exp <- nrow(dif_exp)
ensembl_gene_converted <- nrow(gene_id)
cytoscape_string <- nrow(node_list)
pcsf_subnet <- length(kylie_subnet)
unique_ids <- nrow(kylie_pcsf_master_ranked)

# create summary
cat(paste("Raw gene list =", raw_gene_list, "--> Initial subset (>1 in >=0.5) =", initial_subset))
cat(paste("Initial subset =", initial_subset, "--> EdgeR hits (only dif exp genes) =", edgeR_hits_dif_exp))
cat(paste("EdgeR hits =", edgeR_hits_dif_exp, "--> ensembl gene converted =", ensembl_gene_converted))
cat(paste("ensembl gene converted =", ensembl_gene_converted, "--> Cytoscape/STRING =", cytoscape_string))
cat(paste("Cytoscape/STRING =", cytoscape_string, "--> PCSF subnet =", pcsf_subnet))
cat(paste("PCSF subnet =", pcsf_subnet, "--> Druggability CrossRef =", druggability_crossref))
cat(paste("Druggability CrossRef =", druggability_crossref, "--> Unique IDs =", unique_ids))
```

<br>

<br>

<details>
<summary>Score correlations</summary>
```{r PocketMiner correlation, echo=FALSE, out.width='50%', fig.show='hold'}
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)
pocketminer_data <- read.csv("../../../pocketminer/results/pocketminer_results.csv")
kylie_pcsf_master <- merge(kylie_pcsf_master, pocketminer_data, by = "ID")

plot_data <- subset(kylie_pcsf_master, select = c("max_hit", "num_hits"))
plot_data <- plot_data[plot_data$max_hit >= 0.7, ]



ggplot(plot_data, aes(x = max_hit, y = num_hits)) +
  geom_point() +
  theme(panel.background = element_blank()) +
  xlab("Largest cryptic pocket") +
  ylab("Number of cryptic pockets")

ggplot(kylie_pcsf_master, aes(x = druggability, y = num_drug_pockets)) +
  geom_point() +
  theme(panel.background = element_blank()) +
  xlab("Largest druggable pocket") +
  ylab("Number of druggable pockets")
```
</details>

<br>

## Alternative Rank Testing {.tabset .tabset-pills}

### Rank Sensitivity
```{r rank sensitivity, echo=FALSE}
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

num_drug_pockets_norm <- (kylie_pcsf_master$num_drug_pockets - min(kylie_pcsf_master$num_drug_pockets)) / (max(kylie_pcsf_master$num_drug_pockets) - min(kylie_pcsf_master$num_drug_pockets))

# Define the number of weight values (genes in top x) to test (including 0)
# i.e. 0, 0.1, 0.2, 0.3, ..., 1
num_weights <- 11

# Create weight value sequences that sum up to 1
betweeness_w_values <- seq(0, 1, length.out = num_weights)
citation_w_values <- seq(0, 1, length.out = num_weights)
centrality_w_values <- seq(0, 1, length.out = num_weights)
druggability_w_values <- seq(0, 1, length.out = num_weights)

# Calculate the total number of iterations
total_iterations <- num_weights ^ 4

# Create a progress bar
pb <- progress_bar$new(total = total_iterations)

# Create an empty data frame with proper column names
sensitivity_results <- data.frame(
  betweeness_weight = numeric(),
  citation_weight = numeric(),
  centrality_weight = numeric(),
  druggability_weight = numeric(),
  top_genes = character(),
  stringsAsFactors = FALSE
)

# Perform sensitivity test
for (betweeness_w in betweeness_w_values) {
  for (citation_w in citation_w_values) {
    for (centrality_w in centrality_w_values) {
      for (druggability_w in druggability_w_values) {
        # Check if the weights sum up to 1
        if (betweeness_w + citation_w + centrality_w + druggability_w == 1) {
          # Combine scores using current weights
          combined_score <- betweeness_w * betweeness_norm +
            centrality_w * centrality_norm +
            druggability_w * kylie_pcsf_master$druggability -
            citation_w * citation_norm
          
          # Rank the genes based on the combined score
          kylie_pcsf_master_ranked <- kylie_pcsf_master
          kylie_pcsf_master_ranked$combined_score <- combined_score
          kylie_pcsf_master_ranked <- kylie_pcsf_master_ranked[order(-kylie_pcsf_master_ranked$combined_score), ]
          
          # Select the top 10 genes
          top_genes <- head(kylie_pcsf_master_ranked$external_gene_name, 10)
          
          # Add results to the sensitivity_results data frame
          sensitivity_results <- rbind(sensitivity_results, list(
            betweeness_weight = betweeness_w,
            citation_weight = citation_w,
            centrality_weight = centrality_w,
            druggability_weight = druggability_w,
            top_genes = paste(top_genes, collapse = ', ')
          ))
        }
        
        # Increment the progress bar
        pb$tick()
      }
    }
  }
}

# Split the "top_genes" column into a list of genes
sensitivity_results$top_genes_list <- strsplit(sensitivity_results$top_genes, ', ')

# Count the occurrences of each gene
all_genes <- unlist(sensitivity_results$top_genes_list)
all_genes_unique <- unique(all_genes)
count <- sapply(all_genes_unique, function(g) sum(sapply(sensitivity_results$top_genes_list, function(lst) g %in% lst)))

# Create an empty data frame to store gene counts
gene_counts <- data.frame(
  gene = all_genes_unique,
  count = count,
  stringsAsFactors = FALSE
)

# Sort the gene counts by count
gene_counts <- gene_counts[order(-gene_counts$count), ]



counts_when_betweeness_0 <- sensitivity_results[
  sensitivity_results$betweeness_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "druggability_weight")]) != 0, 
  ]
counts_when_betweeness_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_betweeness_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_betweeness_0)

counts_when_centrality_0 <- sensitivity_results[
  sensitivity_results$centrality_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "betweeness_weight", "druggability_weight")]) != 0, 
]
counts_when_centrality_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_centrality_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_centrality_0)

counts_when_citation_0 <- sensitivity_results[
  sensitivity_results$citation_weight == 0 &
    rowSums(sensitivity_results[, c("betweeness_weight", "centrality_weight", "druggability_weight")]) != 0, 
]
counts_when_citation_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_citation_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_citation_0)

counts_when_druggability_0 <- sensitivity_results[
  sensitivity_results$druggability_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight")]) != 0, 
]
counts_when_druggability_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_druggability_0$top_genes_list, function(lst) g %in% lst)))

final_gene_counts <- cbind(gene_counts, counts_when_druggability_0)

# add gene description
gene_description <- getBM(attributes = c("external_gene_name", "description"), 
                          filters = "external_gene_name", 
                          values = final_gene_counts$gene, 
                          mart = ensembl)

final_gene_counts <- merge(gene_description, final_gene_counts, by.x = "external_gene_name", by.y = "gene")

final_gene_counts <- final_gene_counts[order(-final_gene_counts$count), ]

final_gene_counts$description <- gsub("\\s*\\[.*?\\]", "", final_gene_counts$description)

rownames(final_gene_counts) <- NULL

kable(final_gene_counts, format = "html", caption = "Rank Sensitivity") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "1000px")
```

### Rank Sensitivity w/ Num Drug Pockets
```{r Rank Sensitivity w/ Num Drug Pockets, echo=FALSE}
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

num_drug_pockets_norm <- (kylie_pcsf_master$num_drug_pockets - min(kylie_pcsf_master$num_drug_pockets)) / (max(kylie_pcsf_master$num_drug_pockets) - min(kylie_pcsf_master$num_drug_pockets))


# Define the number of weight values (genes in top x) to test (including 0)
# i.e. 0, 0.1, 0.2, 0.3, ..., 1
num_weights <- 11

# Create weight value sequences that sum up to 1
betweeness_w_values <- seq(0, 1, length.out = num_weights)
citation_w_values <- seq(0, 1, length.out = num_weights)
centrality_w_values <- seq(0, 1, length.out = num_weights)
druggability_w_values <- seq(0, 1, length.out = num_weights)
num_drug_pockets_w_values <- seq(0, 1, length.out = num_weights)

# Calculate the total number of iterations a.k.a number of variables
total_iterations <- num_weights ^ 5

# Create a progress bar
pb <- progress_bar$new(total = total_iterations)

# Create an empty data frame with proper column names
sensitivity_results <- data.frame(
  betweeness_weight = numeric(),
  citation_weight = numeric(),
  centrality_weight = numeric(),
  druggability_weight = numeric(),
  num_drug_pockets = numeric(),
  top_genes = character(),
  stringsAsFactors = FALSE
)

# Perform sensitivity test
for (betweeness_w in betweeness_w_values) {
  for (citation_w in citation_w_values) {
    for (centrality_w in centrality_w_values) {
      for (druggability_w in druggability_w_values) {
        for(num_drug_pockets_w in num_drug_pockets_w_values) {
          # Check if the weights sum up to 1
          if (betweeness_w + citation_w + centrality_w + druggability_w + num_drug_pockets_w == 1) {
            # Combine scores using current weights
            combined_score <- (betweeness_w * betweeness_norm) +
              (centrality_w * centrality_norm) +
              (druggability_w * kylie_pcsf_master$druggability) +
              (num_drug_pockets_w * num_drug_pockets_norm) -
              (citation_w * citation_norm)
            
            # Rank the genes based on the combined score
            kylie_pcsf_master_ranked <- kylie_pcsf_master
            kylie_pcsf_master_ranked$combined_score <- combined_score
            kylie_pcsf_master_ranked <- kylie_pcsf_master_ranked[order(-kylie_pcsf_master_ranked$combined_score), ]
            
            # Select the top 10 genes
            top_genes <- head(kylie_pcsf_master_ranked$external_gene_name, 10)
            
            # Add results to the sensitivity_results data frame
            sensitivity_results <- rbind(sensitivity_results, list(
              betweeness_weight = betweeness_w,
              citation_weight = citation_w,
              centrality_weight = centrality_w,
              druggability_weight = druggability_w,
              num_drug_pockets_weight = num_drug_pockets_w,
              top_genes = paste(top_genes, collapse = ', ')
            ))
          }
          
          # Increment the progress bar
          pb$tick()
        }
      }
    }
  }
}


# Split the "top_genes" column into a list of genes
sensitivity_results$top_genes_list <- strsplit(sensitivity_results$top_genes, ', ')

# Count the occurrences of each gene
all_genes <- unlist(sensitivity_results$top_genes_list)
all_genes_unique <- unique(all_genes)
count <- sapply(all_genes_unique, function(g) sum(sapply(sensitivity_results$top_genes_list, function(lst) g %in% lst)))

# Create an empty data frame to store gene counts
gene_counts <- data.frame(
  gene = all_genes_unique,
  count = count,
  stringsAsFactors = FALSE
)

# Sort the gene counts by count
gene_counts <- gene_counts[order(-gene_counts$count), ]



counts_when_betweeness_0 <- sensitivity_results[
  sensitivity_results$betweeness_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "druggability_weight", "num_drug_pockets_weight")]) != 0, 
]
counts_when_betweeness_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_betweeness_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_betweeness_0)

counts_when_centrality_0 <- sensitivity_results[
  sensitivity_results$centrality_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "betweeness_weight", "druggability_weight", "num_drug_pockets_weight")]) != 0, 
]
counts_when_centrality_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_centrality_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_centrality_0)

counts_when_citation_0 <- sensitivity_results[
  sensitivity_results$citation_weight == 0 &
    rowSums(sensitivity_results[, c("betweeness_weight", "centrality_weight", "druggability_weight", "num_drug_pockets_weight")]) != 0, 
]
counts_when_citation_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_citation_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_citation_0)

counts_when_druggability_0 <- sensitivity_results[
  sensitivity_results$druggability_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", "num_drug_pockets_weight")]) != 0, 
]
counts_when_druggability_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_druggability_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_druggability_0)

counts_when_num_drug_pockets_0 <- sensitivity_results[
  sensitivity_results$num_drug_pockets_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", "druggability_weight")]) != 0, 
]
counts_when_num_drug_pockets_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_num_drug_pockets_0$top_genes_list, function(lst) g %in% lst)))

gene_counts <- cbind(gene_counts, counts_when_num_drug_pockets_0)

# add gene description
gene_description <- getBM(attributes = c("external_gene_name", "description"), 
                          filters = "external_gene_name", 
                          values = gene_counts$gene, 
                          mart = ensembl)

final_gene_counts <- merge(gene_description, gene_counts, by.x = "external_gene_name", by.y = "gene")

final_gene_counts <- final_gene_counts[order(-final_gene_counts$count), ]

final_gene_counts$description <- gsub("\\s*\\[.*?\\]", "", final_gene_counts$description)

rownames(final_gene_counts) <- NULL

kable(final_gene_counts, format = "html", caption = "Rank Sensitivity") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "1000px")
```

### RRA
```{r RRA + RRA setup, echo=FALSE}
# Robust Rank Agrregation
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

# add the PocketMiner data first becasue missmatch genes that are probably from when small structures were removed
# 300 genes in instead of 302
pocketminer_data <- read.csv("../../../pocketminer/results/pocketminer_results.csv")
#pocketminer_data <- pocketminer_data[pocketminer_data$ID %in% kylie_pcsf_master$ID, ]
kylie_pcsf_master <- merge(kylie_pcsf_master, pocketminer_data, by = "ID")

pocketminer_data <- pocketminer_data[order(kylie_pcsf_master$max_hit, decreasing = T), ]
cryptic_pockets <- pocketminer_data$ID

# reorder for num_hits
pocketminer_data <- pocketminer_data[order(kylie_pcsf_master$num_hits, decreasing = T), ]
num_cryp_pockets <- pocketminer_data$ID



betweenness <- subset(kylie_pcsf_master, select = c("ID", "betweenness"))
#betweenness <- distinct(betweenness)
betweenness$betweenness <- (betweenness$betweenness - min(betweenness$betweenness)) / (max(betweenness$betweenness) - min(betweenness$betweenness))
betweenness <- betweenness[order(betweenness$betweenness, decreasing = T), ]
betweenness <- betweenness$ID

centrality <- subset(kylie_pcsf_master, select = c("ID", "degree_centrality"))
#centrality <- distinct(centrality)
centrality$degree_centrality <- (centrality$degree_centrality - min(centrality$degree_centrality)) / (max(centrality$degree_centrality) - min(centrality$degree_centrality))
centrality <- centrality[order(centrality$degree_centrality, decreasing = T), ]
centrality <- centrality$ID

# log transformation of citation scores
citation <- subset(kylie_pcsf_master, select = c("ID", "citation_score"))
#citation <- distinct(citation)
citation$citation_score <- log(citation$citation_score + 1)
citation$citation_score <- (citation$citation_score - min(citation$citation_score)) / (max(citation$citation_score) - min(citation$citation_score))
citation <- citation[order(citation$citation_score, decreasing = F), ]
citation <- citation$ID

druggability_data <- subset(kylie_pcsf_master, select = c("ID", "druggability", "num_drug_pockets"))
#druggability_data <- distinct(druggability_data)
druggability <- druggability_data[order(druggability_data$druggability, decreasing = T), ]
druggability <- druggability$ID

num_drug_pockets <- druggability_data[order(druggability_data$num_drug_pockets, decreasing = T), ]
num_drug_pockets <- num_drug_pockets$ID



# RRA basic
rankings <- list(betweenness, centrality, citation, druggability)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(kylie_pcsf_master, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

# remove scientific notation
options(scipen=999)

description <- getBM(attributes = c("external_gene_name", "description"), 
                     filters = "external_gene_name", 
                     values = aggregate_ranks$external_gene_name, 
                     mart = ensembl)

description$description <- gsub("\\s*\\[.*?\\]", "", description$description)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

rownames(aggregate_ranks) <- NULL

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "1000px")
```

### RRA w/ Num drug Pockets
```{r RRA w/ number of druggable pockets, echo=FALSE}
# RRA w/ number of druggable pockets
rankings <- list(betweenness, centrality, citation, druggability, num_drug_pockets)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(kylie_pcsf_master, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

# remove scientific notation
options(scipen=999)

description <- getBM(attributes = c("external_gene_name", "description"), 
                     filters = "external_gene_name", 
                     values = aggregate_ranks$external_gene_name, 
                     mart = ensembl)

description$description <- gsub("\\s*\\[.*?\\]", "", description$description)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

rownames(aggregate_ranks) <- NULL

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "1000px")
```

### Rank Sensitivity w/ all factors
```{r Rank Sensitivity w/ all factors, echo=FALSE}
kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

pocketminer_data <- read.csv("../../../pocketminer/results/pocketminer_results.csv")
kylie_pcsf_master <- merge(kylie_pcsf_master, pocketminer_data, by = "ID")



betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

num_drug_pockets_norm <- (kylie_pcsf_master$num_drug_pockets - min(kylie_pcsf_master$num_drug_pockets)) / (max(kylie_pcsf_master$num_drug_pockets) - min(kylie_pcsf_master$num_drug_pockets))

num_cryp_pockets_norm <- (kylie_pcsf_master$num_hits - min(kylie_pcsf_master$num_hits)) / (max(kylie_pcsf_master$num_hits) - min(kylie_pcsf_master$num_hits))



# Define the number of weight values (genes in top x) to test (including 0)
# i.e. 0, 0.1, 0.2, 0.3, ..., 1
num_weights <- 11

# Create weight value sequences that sum up to 1
betweeness_w_values <- seq(0, 1, length.out = num_weights)
citation_w_values <- seq(0, 1, length.out = num_weights)
centrality_w_values <- seq(0, 1, length.out = num_weights)
druggability_w_values <- seq(0, 1, length.out = num_weights)
cryptic_pocket_w_values <- seq(0, 1, length.out = num_weights)
num_drug_pockets_w_values <- seq(0, 1, length.out = num_weights)
num_cryp_pockets_w_values <- seq(0, 1, length.out = num_weights)

# Calculate the total number of iterations a.k.a number of variables
total_iterations <- num_weights ^ 7

# Create a progress bar
pb <- progress_bar$new(total = total_iterations)

# Create an empty data frame with proper column names
sensitivity_results <- data.frame(
  betweeness_weight = numeric(),
  citation_weight = numeric(),
  centrality_weight = numeric(),
  druggability_weight = numeric(),
  cryptic_pocket_weight = numeric(),
  num_drug_pockets = numeric(),
  num_cryp_pockets = numeric(),
  top_genes = character(),
  stringsAsFactors = FALSE
)

# Perform sensitivity test
for (betweeness_w in betweeness_w_values) {
  for (citation_w in citation_w_values) {
    for (centrality_w in centrality_w_values) {
      for (druggability_w in druggability_w_values) {
        for(num_drug_pockets_w in num_drug_pockets_w_values) {
          for (cryptic_pocket_w in cryptic_pocket_w_values) {
            for (num_cryp_pockets_w in num_cryp_pockets_w_values) {
              # Check if the weights sum up to 1
              if (betweeness_w + citation_w + centrality_w + druggability_w + num_drug_pockets_w + cryptic_pocket_w + num_cryp_pockets_w == 1) {
                # Combine scores using current weights
                combined_score <- (betweeness_w * betweeness_norm) +
                  (centrality_w * centrality_norm) +
                  (druggability_w * kylie_pcsf_master$druggability) +
                  (num_drug_pockets_w * num_drug_pockets_norm) +
                  (cryptic_pocket_w * kylie_pcsf_master$max_hit) +
                  (num_cryp_pockets_w * num_cryp_pockets_norm) -
                  (citation_w * citation_norm)
                
                # Rank the genes based on the combined score
                kylie_pcsf_master_ranked <- kylie_pcsf_master
                kylie_pcsf_master_ranked$combined_score <- combined_score
                kylie_pcsf_master_ranked <- kylie_pcsf_master_ranked[order(-kylie_pcsf_master_ranked$combined_score), ]
                
                # Select the top 10 genes
                top_genes <- head(kylie_pcsf_master_ranked$external_gene_name, 10)
                
                # Add results to the sensitivity_results data frame
                sensitivity_results <- rbind(sensitivity_results, list(
                  betweeness_weight = betweeness_w,
                  citation_weight = citation_w,
                  centrality_weight = centrality_w,
                  druggability_weight = druggability_w,
                  num_drug_pockets_weight = num_drug_pockets_w,
                  cryptic_pocket_weight = cryptic_pocket_w,
                  num_cryp_pockets_weight = num_cryp_pockets_w,
                  top_genes = paste(top_genes, collapse = ', ')
                ))
              }
              
              # Increment the progress bar
              pb$tick()
            }
          }  
        }
      }
    }
  }
}


# Split the "top_genes" column into a list of genes
sensitivity_results$top_genes_list <- strsplit(sensitivity_results$top_genes, ', ')

# Count the occurrences of each gene
all_genes <- unlist(sensitivity_results$top_genes_list)
all_genes_unique <- unique(all_genes)
count <- sapply(all_genes_unique, function(g) sum(sapply(sensitivity_results$top_genes_list, function(lst) g %in% lst)))

# Create an empty data frame to store gene counts
gene_counts <- data.frame(
  gene = all_genes_unique,
  count = count,
  stringsAsFactors = FALSE
)

# Sort the gene counts by count
gene_counts <- gene_counts[order(-gene_counts$count), ]


# add scores when variable = 0
counts_when_betweeness_0 <- sensitivity_results[
  sensitivity_results$betweeness_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "druggability_weight", 
                                    "num_drug_pockets_weight", "cryptic_pocket_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_betweeness_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_betweeness_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_betweeness_0)


counts_when_centrality_0 <- sensitivity_results[
  sensitivity_results$centrality_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "betweeness_weight", "druggability_weight", 
                                    "num_drug_pockets_weight", "cryptic_pocket_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_centrality_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_centrality_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_centrality_0)


counts_when_citation_0 <- sensitivity_results[
  sensitivity_results$citation_weight == 0 &
    rowSums(sensitivity_results[, c("betweeness_weight", "centrality_weight", "druggability_weight", 
                                    "num_drug_pockets_weight", "cryptic_pocket_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_citation_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_citation_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_citation_0)


counts_when_druggability_0 <- sensitivity_results[
  sensitivity_results$druggability_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", 
                                    "num_drug_pockets_weight", "cryptic_pocket_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_druggability_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_druggability_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_druggability_0)


counts_when_num_drug_pockets_0 <- sensitivity_results[
  sensitivity_results$num_drug_pockets_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", 
                                    "druggability_weight", "cryptic_pocket_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_num_drug_pockets_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_num_drug_pockets_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_num_drug_pockets_0)


counts_when_cryptic_pockets_0 <- sensitivity_results[
  sensitivity_results$cryptic_pocket_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", 
                                    "druggability_weight", "num_drug_pockets_weight", "num_cryp_pockets_weight")]) != 0, ]
counts_when_cryptic_pockets_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_cryptic_pockets_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_cryptic_pockets_0)


counts_when_num_cryp_pockets_0 <- sensitivity_results[
  sensitivity_results$num_cryp_pockets_weight == 0 &
    rowSums(sensitivity_results[, c("citation_weight", "centrality_weight", "betweeness_weight", 
                                    "druggability_weight", "cryptic_pocket_weight", "num_drug_pockets_weight")]) != 0, ]
counts_when_num_cryp_pockets_0 <- sapply(all_genes_unique, function(g) sum(sapply(counts_when_num_cryp_pockets_0$top_genes_list, function(lst) g %in% lst)))
gene_counts <- cbind(gene_counts, counts_when_num_cryp_pockets_0)



# add gene description
gene_description <- getBM(attributes = c("external_gene_name", "description"), 
                          filters = "external_gene_name", 
                          values = gene_counts$gene, 
                          mart = ensembl)

final_gene_counts <- merge(gene_description, gene_counts, by.x = "external_gene_name", by.y = "gene")

final_gene_counts <- final_gene_counts[order(-final_gene_counts$count), ]

final_gene_counts$description <- gsub("\\s*\\[.*?\\]", "", final_gene_counts$description)

rownames(final_gene_counts) <- NULL

kable(final_gene_counts, format = "html", caption = "Rank Sensitivity") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "1000px")
```

### RRA w/ all factors
```{r RRA all, echo=FALSE}
# RRA all
rankings <- list(betweenness, centrality, citation, druggability, num_drug_pockets, cryptic_pockets, num_cryp_pockets)


aggregate_ranks <- aggregateRanks(glist = rankings)

# merge gene names back in
temp <- subset(kylie_pcsf_master, select = c("external_gene_name", "ID"))
aggregate_ranks <- merge(temp, aggregate_ranks, by.x = "ID", by.y = "Name")
rm(temp)

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

# remove scientific notation
options(scipen=999)

description <- getBM(attributes = c("external_gene_name", "description"), 
                     filters = "external_gene_name", 
                     values = aggregate_ranks$external_gene_name, 
                     mart = ensembl)

description$description <- gsub("\\s*\\[.*?\\]", "", description$description)

aggregate_ranks <- merge(description, aggregate_ranks, by = "external_gene_name")

aggregate_ranks <- aggregate_ranks[order(aggregate_ranks$Score), ]

rownames(aggregate_ranks) <- NULL

kable(aggregate_ranks, format = "html", caption = "Robust Rank Aggregation") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "1000px")
```

##

<br>

<br>

end of doc

