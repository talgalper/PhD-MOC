---
title: "MOC PCSF Pipeline"
output: html_document
date: "2023-11-16"
---

```{r load packages, include=FALSE}
library(PCSF)
library(plyr)
library(biomaRt)
library(dplyr)
library(tidyr)
library(kableExtra)
library(grid)
library(edgeR)
library(ggplot2)
library(reshape2)


ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
```

## Description

The genes in this pipeline are those identified to be differentially expressed (DE) in stage_I, stage_II, stage_III and stage_IV samples. Run with interaction data from DE gene list in STRING. In this run, no cutoff is used for DE genes i.e. -3 to 3 (used all DE genes).

<br> 

See end of doc for gene subset summary 

<br>

<details>

<summary>Show Kylie raw data treatment</summary>

```{r seperate based on stage, eval=FALSE}
sample_info <- read.csv("data/All survival_CN_Aug18.csv")
sample_info <- subset(sample_info, select = c("GAMUT_ID", "Grade", "Stage"))

kylie_counts <- read.csv("data/analysis_set_raw_counts.csv", row.names = 1)

# Extract column names
column_names <- colnames(kylie_counts)

# Remove "GAMuT_" part from column names
gamut_ids <- sub("^GAMuT_", "", column_names)


# create list of stage ids 
stage_I <- c("I","IA","IB","IC")
stage_II <- c("II", "IIA", "IIB", "IIC")
stage_III <- c("III", "IIIA", "IIIB", "IIIC", "IIIc")
stage_IV <- c("IV")
stage_ids <- list(stage_I, stage_II, stage_III, stage_IV)

# common GAMuT IDs between sample_info and kylie_counts
matching_ids <- intersect(gamut_ids, sample_info$GAMUT_ID)

stage_df <- list()

for (stage in stage_ids) {
  # sanity check
  print(stage)
  # retrieve GAMuT ID for the stage
  stage_id <- sample_info[sample_info$Stage %in% stage, 1]
  # common GAMuT IDs between stage and matching_ids
  matching_stage_id <- intersect(matching_ids, stage_id)
  # subset the kylie_counts df based on the IDs from matching_stage_id
  subset_stage_counts <- kylie_counts[, paste0("GAMuT_", matching_stage_id)]
  # add it to the df list
  stage_df <- c(stage_df, list(subset_stage_counts))
}

# retrieve each df from the list and save a separate variable
stage_I <- stage_df[[1]]
stage_II <- stage_df[[2]]
stage_III <- stage_df[[3]]
stage_IV <- as.data.frame(stage_df[[4]])
colnames(stage_IV) <- paste0("GAMuT_", matching_stage_id)
rownames(stage_IV) <- rownames(kylie_counts)


write.csv(stage_I, "data/stage_I_master_df.csv")
write.csv(stage_II, "data/stage_II_master_df.csv")
write.csv(stage_III, "data/stage_III_master_df.csv")
write.csv(stage_IV, "data/stage_IV_master_df.csv")


## subset benign samples
ben_rows <- subset(sample_info, Grade == "BEN")
ben_id <- ben_rows$GAMUT_ID
matching_ben_id <- intersect(matching_ids, ben_id)
subset_ben_counts <- kylie_counts[, paste0("GAMuT_", matching_ben_id)]

write.csv(subset_ben_counts, "data/ben_master_df.csv")

#bdl_rows <- subset(sample_info, Grade == "BDL")
```

</details>

<br>

### Gene Subset Progression

The raw data consists of 14,889 genes which was subject to removal of low acitvity genes by subsetting those that have a CPM of more than 1 in at least 50% of the samples.

<br>

-   Stage_I = 36

-   Stage_II = 2 files

-   Stage_III = 5 files

-   Stage_IV = 1 files

-   Benign = 11

<br>

FALSE = Failed genes
```{r remove low activity genes, echo=FALSE}
# combine stage I, II, III and IV
stage_I <- read.csv("data/stage_I_master_df.csv")
stage_II <- read.csv("data/stage_II_master_df.csv")
stage_III <- read.csv("data/stage_III_master_df.csv")
stage_IV <- read.csv("data/stage_IV_master_df.csv")

# merge disease groups together
kylie_data <- merge(stage_I, stage_II, by = "X")
kylie_data <- merge(kylie_data, stage_III, by = "X")
kylie_data <- merge(kylie_data, stage_IV, by = "X")

colnames(kylie_data)[1] <- "gene_id"

benign_data <- read.csv("data/ben_master_df.csv")
colnames(benign_data)[1] <- "gene_id"
# Get the current column names
current_names <- colnames(benign_data)
# Create new column names by replacing "GAMuT_" with "BEN_"
new_names <- sub("GAMuT_", "BEN_", current_names)
# Assign the new column names to the data frame
colnames(benign_data) <- new_names

# combine into single df
df <- inner_join(kylie_data, benign_data, by = c("gene_id"))
rownames(df) <- df$gene_id
df <- df[, -1]
raw_gene_list <- nrow(kylie_data)

gene_id <- rownames(df)
#kylie_data <- kylie_data[, -1] # remove gene ids for rowSums calc

# subset genes that have a cpm of greater than one in more than 50% of the samples
keepTheseGenes <- (rowSums(cpm(df) > 1) >= ncol(df)/2)
print(summary(keepTheseGenes))

# add gene ids back into df
#df <- cbind(gene_id, df)

removedGenes <- rownames(df)[!keepTheseGenes]
removedGenes <- as.data.frame(removedGenes)
colnames(removedGenes)[1] <- "gene_id"

df <- df[keepTheseGenes, ]

initial_subset <- nrow(df)
```

<details>

<summary>Show low acitivty genes</summary>
```{r echo=FALSE}
removed_converted <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = removedGenes$gene_id, 
                       mart = ensembl)

kable(removed_converted, format = "html", caption = "Low count genes") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

<br>

<br>

## Step 1: Differential expression analysis using edgeR

```{r differential expression, echo=FALSE, warning=FALSE}
# Select the columns that start with "GAMuT"
cols <- grep("^GAMuT", colnames(df))

# Assign the unstranded columns to the cancer group
cancer <- colnames(df)[cols]

# Assign the rest of the columns to the healty group
benign <- setdiff(colnames(df), cancer)

# Create the group variable
group <- factor(c(rep("cancer", length(cancer)), rep("benign", length(benign))))

data <- DGEList(counts = df, group = group)

design <- model.matrix(~group)

# Estimate a common negative binomial dispersion parameter for a DGE dataset with a general experimental design
common <- estimateGLMCommonDisp(data, design, verbose = T)

# Estimate the abundance-dispersion trend by Cox-Reid approximate profile likelihood.
trend <- estimateGLMTrendedDisp(common, design)

# Compute an empirical Bayes estimate of the negative binomial dispersion parameter for each tag, 
# with expression levels specified by a log-linear model.
tagwise <- estimateGLMTagwiseDisp(trend, design)

# Fit a negative binomial generalized log-linear model to the read counts for each gene. 
# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
fit <- glmFit(tagwise, design)

# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
lrt <- glmLRT(fit, coef = 2)

# Extract the most differentially expressed genes (or sequence tags) from a test object, 
# ranked either by p-value or by absolute log-fold-change.
toptags <- topTags(lrt, n = Inf)

# Identify which genes are significantly differentially expressed from 
# an edgeR fit object containing p-values and test statistics.
dif_exp <- decideTestsDGE(lrt, p = 0.05, adjust = "fdr", lfc = 1)
print(summary(dif_exp))

dif_exp_genes <- rownames(tagwise)[as.logical(dif_exp)]

# create a results df
hits <- toptags$table[toptags$table$FDR < 0.1, ]
colnames <- colnames(hits)
hits$gene_id <- rownames(hits)
hits <- hits[,c("gene_id", colnames)]

dif_exp <- hits[dif_exp_genes, ]

non_dif_exp_genes <- hits[hits$gene_id != dif_exp_genes, ]

write.csv(hits, "intermediate/edgeR/edgeR_hits.csv")
write.csv(dif_exp, "intermediate/edgeR/edgeR_dif_exp_genes.csv")
write.csv(non_dif_exp_genes, "intermediate/edgeR/non_dif_exp_genes.csv")
```
<br>

```{r plot DE data, echo=FALSE, out.width='33%', fig.show='hold'}
# Plot the genewise biological coefficient of variation (BCV) against gene abundance (in log2 counts per million).
plotBCV(tagwise, main = "Biological coefficient of variation")

# Make a mean-difference plot of two libraries of count data with smearing of points with very low counts, 
# especially those that are zero for one of the columns.
plotSmear(lrt, de.tags = dif_exp_genes, main = "Mean-difference plot")

# plot Pvalues of different logFC scores
ggplot(hits, aes(x=logFC, y=-log(FDR))) + geom_point() + labs(title = "Adjusted logFC")
```

```{r include=FALSE, eval=FALSE}
rm(list = ls()[!ls() %in% c("ensembl")])
```

<br>

## Step 2: PCSF file prep - Create score file and format STRING interaction data

-   Convert gene ensembl to gene symbol

-   Create score file from logFC values

-   Feed list of proteins into STRING/Cytoscape

-   Format output and create interaction file

<br>

<details>

<summary>Show code</summary>

```{r PCSF score file}
## convert to gene names and create list for STRING

# read in the data
kylie_data <- read.csv("intermediate/edgeR/edgeR_dif_exp_genes.csv")

# subset the gene_id and logFC columns
kylie_data <- subset(kylie_data, select = c("gene_id", "logFC"))

# convert to gene symbol
gene_id <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = kylie_data$gene_id, 
                       mart = ensembl)

# remove empty rows
gene_id <- subset(gene_id, external_gene_name != "") # uniprot_gn_symbol = 772

# check for duplicate uniprot ids
gene_id <- distinct(gene_id)

# merge back with original data
colnames(gene_id)[1] <- "gene_id"

kylie_gene_data <- merge(gene_id, kylie_data, by = "gene_id")

kylie_gene_data <- subset(kylie_gene_data, select = c("external_gene_name", "logFC"))

# check to see if genes that at all genes were converted at least once
missing_genes <- anti_join(kylie_data, gene_id, by = "gene_id")

# create score file
write.csv(kylie_gene_data, "intermediate/PCSF_data/pcsf_kylie_score.csv")

## create ensemble protein list for interaction db
write.table(kylie_gene_data$external_gene_name, "intermediate/cytoscape/kylie_gene_list.txt", row.names = F, col.names = F, quote = F)
```

```{r format STRING output}
string_edge_data <- read.table("intermediate/cytoscape/STRING network (physical) default edge.csv", header = T, sep = ",", stringsAsFactors = F)
ppi_list <- subset(string_edge_data, select = c("name", "stringdb..score"))
ppi_list <- ppi_list %>% 
  separate(name, sep = " ", into = c("node_1", "del", "node_2"))
ppi_list <- subset(ppi_list, select = c("node_1", "node_2", "stringdb..score"))
ppi_list$node_1 <- gsub(".*.\\.", "", ppi_list$node_1)
ppi_list$node_2 <- gsub(".*.\\.", "", ppi_list$node_2)

string_node_data <- read.table("intermediate/cytoscape/STRING network (physical) default node.csv", header = T, sep = ",", stringsAsFactors = F)
node_list <- subset(string_node_data, select = c("name", "query.term"))
node_list$name <- gsub(".*.\\.", "", node_list$name)
ppi_list$original_order <- seq_len(nrow(ppi_list))
merged_df <- merge(ppi_list, node_list, by.x = "node_1", by.y = "name", all.x = TRUE)
merged_df <- merge(merged_df, node_list, by.x = "node_2", by.y = "name", all.x = TRUE)
merged_df <- merged_df[order(merged_df$original_order), ]

final_df <- merged_df[, c("query.term.x", "query.term.y", "stringdb..score")]
colnames(final_df) <- c("node_1", "node_2", "score")

write.csv(final_df, "intermediate/PCSF_data/STRING_data.csv")


# create gene_id uniprot_id ref list.
ref_list <- getBM(attributes = c("external_gene_name","uniprot_gn_id"),
                  filters = "external_gene_name", 
                  values = node_list$query.term, 
                  mart = ensembl)
```

</details>

<br>

## Step 3: Run PCSF and create cross reference results with AF structures for durggability

```{r run PCSF, echo=FALSE}
# set seed for reproducibility 
set.seed(1234)

# read in STRING data
#kylie_string_data <- read.csv("string_run/interaction_score.csv", row.names = 1)

# construct interactome
kylie_ppi <- construct_interactome(final_df)

# read in score file
#kylie_data <- read.csv("string_run/pcsf_kylie_score.csv", row.names = 1)

# set terminals
kylie_terminals <- setNames(as.numeric(kylie_gene_data$logFC), kylie_gene_data$external_gene_name)

# run PCSF with random noise

# time a pcsf run
start_time <- Sys.time()
kylie_subnet <- PCSF_rand(kylie_ppi, kylie_terminals, n = 50, r = 0.1, w = 2, b = 1, mu = 0.0005)
elapsed_time <- Sys.time() - start_time
print(elapsed_time)

plot.PCSF(kylie_subnet, node_label_cex = 15)
```

<br>

```{r extract network metrics, include=FALSE}
# extract cluster data
kylie_clust <- clusters(kylie_subnet)
kylie_df <- data.frame(gene_id = names(kylie_clust$membership), cluster = factor(kylie_clust$membership))
kylie_betweenness <- betweenness(kylie_subnet) 
kylie_centrality <- degree(kylie_subnet) 
kylie_df$betweenness <- kylie_betweenness[as.character(kylie_df$gene_id)]
kylie_df$degree_centrality <- kylie_centrality[as.character(kylie_df$gene_id)]
kylie_df$betweenness <- as.integer(kylie_df$betweenness)
kylie_df$degree_centrality <- as.integer(kylie_df$degree_centrality)

rownames(kylie_df) <- 1:nrow(kylie_df)

kylie_df <- kylie_df[order(kylie_df$cluster), ]

write.csv(kylie_df, "results/PCSF_results.csv", row.names = F)
```

```{r tabulate PCSF data, echo=FALSE}
kylie_df <- kylie_df[order(kylie_df$degree_centrality), ]

kable(kylie_df, format = "html", caption = "PCSF Nertwork Metrics") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

<br>

## Step 4: Combine Structural and Citation data
```{r add fpocket data, include=FALSE}
# read in data
af_drugability <- read.csv("../../../druggability_results/fpocket_druggability.csv")
kylie_pcsf <- read.csv("results/PCSF_results.csv")
kylie_pcsf <- merge(ref_list, kylie_pcsf, by.x = "external_gene_name", by.y = "gene_id")

# merge AF data with PCSF data by uniprot ID
kylie_pcsf_master <- merge(kylie_pcsf, af_drugability, by.x = "uniprot_gn_id", by.y = "uniprot_id")

kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]

druggability_crossref <- nrow(kylie_pcsf_master)

write.csv(kylie_pcsf_master, "results/MOC_PCSF_drugability.csv")
```

Note: The citation scores for this data were generated using PubMed API

```{r add up/down reg + citation scores, echo=FALSE}
# add up and down regulaiton tags to table
up_or_down <- read.csv("intermediate/PCSF_data/pcsf_kylie_score.csv", row.names = 1)
up_or_down$regulation <- ifelse(up_or_down$logFC > 0, "up_reg", "dn_reg")
colnames(up_or_down)[1] <- "gene_id"
kylie_pcsf_master <- read.csv("results/MOC_PCSF_drugability.csv", row.names = 1)
kylie_pcsf_master <- merge(kylie_pcsf_master, up_or_down, by.x = "external_gene_name", by.y = "gene_id")


# run the citation score script now using kylie_PCSF_drugability.csv

# add citation scores
cit_scores <- read.csv("intermediate/citation_scores.csv")
kylie_pcsf_master <- merge(kylie_pcsf_master, cit_scores, by.x = "external_gene_name", by.y = "gene_id")

kylie_pcsf_master <- kylie_pcsf_master[order(-kylie_pcsf_master$druggability), ]
rownames(kylie_pcsf_master) <- NULL

# remove duplicates
master_unique <- kylie_pcsf_master[!duplicated(kylie_pcsf_master$external_gene_name), ]

rownames(master_unique) <- NULL

write.csv(kylie_pcsf_master, "results/MOC_PCSF_master.csv")
write.csv(master_unique, "results/MOC_PCSF_master_unique.csv")
```

<details>

<summary>Show raw table</summary>

```{r tabulate data, echo=FALSE}
kable(kylie_pcsf_master, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

```{r tabulate unique data, echo=FALSE}
kable(master_unique, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

## Step 5: Functional Enrichment Analysis

<details>

<summary>Show code</summary>

```{r enrichment, echo=FALSE}
enrichment_analysis_edit <-function(subnet, mode=NULL, gene_universe){
  
  # Checking function arguments
  if (missing(subnet))
    stop("Need to specify the subnetwork obtained from the PCSF algorithm.")
  if (class(subnet)[1] != "PCSF" || class(subnet)[2] != "igraph")
    stop("The subnetwork must be a \"PCSF\" object derived from an \"igraph\" class.")
  if (!is.null(mode)){
    if(mode==1 && missing(gene_universe))
      stop("Need to specify a list of genes (vector of gene symbols) used as background in enrichment analysis by topGO package")
  }
  
  
  cat("  Performing enrichment analysis...\n\n")
  
  # Obtain clusters in the subnet using edge betweenness clustering algorithm from igraph package.
  clusters = cluster_edge_betweenness(subnet)
  
  # Perform ebrichment analysis for each cluster using EnrichR through its API or topGO.
  #print("Performing enrichment analysis...")
  #print(paste("Number of clusters:", length(clusters$membership)))
  
  havingInternet <- function() {
    if (.Platform$OS.type == "windows") {
      ipmessage <- system("ipconfig", intern = TRUE)
    } else {
      ipmessage <- system("ifconfig", intern = TRUE)
    }
    validIP <- "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)[.]){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    any(grep(validIP, ipmessage))
  }
  
  internet_connection <- havingInternet()
  
  if(!is.null(mode)){
    if(mode==0){
      if(internet_connection){
        cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
        enrich = call_enr(clusters, mode = 0, gene_universe)
      }
      else{
        stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
      }
    }
    else{
      cat("  Enrichment is being performed by topGO package ...\n")
      enrich = call_enr(clusters, mode = mode, gene_universe)
    }
  }
  else
  {
    if(internet_connection){
      cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
      enrich = call_enr(clusters, mode = 0, gene_universe)
    }
    else{
      stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
    }
  }
  
  if('Compound'%in% V(subnet)$type){##then we have drugs!
    require(dplyr)
    comps=data.frame(Drug=V(subnet)$name[which(V(subnet)$type=='Compound')],
                     Cluster=clusters$membership[which(V(subnet)$type=='Compound')])%>%
      dplyr::group_by(Cluster)%>%
      dplyr::summarise(DrugsByBetweenness=paste(Drug,collapse=';'))
    
  }
  else{
    comps <-NULL
  }
  enrichment = enrich[[1]]
  enrichment_complete = enrich[[2]]
  print(paste("Number of enrichment results:", length(enrichment_complete)))
  
  #for (x in 1:length(enrichment_complete)) {
  #  print(paste("Cluster", x, "enrichment complete:", enrichment_complete[[x]]))
  #}
  
  novals<-which(unlist(sapply(enrich[[2]],function(x) is.null(dim(x)))))
  if(length(novals)>0)
    enrichment_complete <- enrichment_complete[-novals]
  
  enrichment_tab <- do.call(rbind, lapply(seq_along(enrichment_complete), function(x) {
    if (!is.null(dim(enrichment_complete[[x]]))) {
      data.frame(Cluster = x, enrichment_complete[[x]])
    } else {
      NULL
    }
  }))
  
  more.than.two <- which(sapply(enrichment_tab$Genes, function(x) length(unlist(strsplit(x, split = ';')))) > 2)
  if (length(more.than.two) > 0)
    enrichment_tab <- enrichment_tab[more.than.two, ]
  
  if(!is.null(comps))
    enrichment_tab = enrichment_tab%>%dplyr::left_join(comps,by='Cluster')
  
  # Add 'group" and 'title' attributes to subnet
  V(subnet)$group = clusters$membership
  V(subnet)$title = paste0("Cluster ",clusters$membership,": Enrichment analysis")
  for( i in 1:length(V(subnet))){
    V(subnet)$title[i] = paste0( V(subnet)$title[i], enrichment[[V(subnet)$group[i]]])
  }
  
  # Derive a "PCSFe" object from an "igraph" class.
  class(subnet) <- c("PCSFe", "igraph")
  # Combine the subnetwork and colplete enrichment analysis tables.
  output = list(subnet, enrichment_tab)
  names(output) = c("subnet", "enrichment")
  
  return (output)
}

# functional enrichment using enrichR
res <- enrichment_analysis_edit(kylie_subnet)
```

</details>

<br>

#### Tip: Hover over nodes for details!

```{r plot enrichment, echo=FALSE}
plot.PCSFe(res$subnet, edge_width = 8, node_size = 30, node_label_cex = 1)
```

<br>

Note: P-value represents likelihood of observing that pathway by random chance. The top 15 functional enrichment terms for each cluster are ranked according to the adjusted p-value. This is what you observe when you hover your mouse over a node in that cluster.

<br>

```{r extarct enrichment data, include=FALSE}
enrichment_results <- res$enrichment

# Create a data frame with the enrichment results
enrichment_table <- data.frame(
  Cluster = enrichment_results$Cluster,
  Term = enrichment_results$Term,
  PValue = enrichment_results$P.value,
  Adjusted_Pvalue = enrichment_results$Adjusted.P.value,
  Genes = enrichment_results$Genes)

write.csv(enrichment_table, "results/enrichR_results.csv")
```

<details>

<summary>Tabulated format</summary>

```{r tabulate enrichment, echo=FALSE}
kable(enrichment_table, format = "html", caption = "Enrichment Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

</details>

<br>

<br>

## Weighted Gene Ranking

In this table the genes are ordered by their combined rank score which is a normalised score with the following contributions:

-   Betweeness: 10%
-   Citation score: 20%
-   Degree centrality: 30%
-   Druggability: 40%

<br>

```{r apply custom weights, echo=FALSE}
# normalize scores for overall rank

kylie_pcsf_master <- read.csv("results/MOC_PCSF_master_unique.csv", row.names = 1)

betweeness_norm <- (kylie_pcsf_master$betweenness - min(kylie_pcsf_master$betweenness)) / (max(kylie_pcsf_master$betweenness) - min(kylie_pcsf_master$betweenness))

centrality_norm <- (kylie_pcsf_master$degree_centrality - min(kylie_pcsf_master$degree_centrality)) / (max(kylie_pcsf_master$degree_centrality) - min(kylie_pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(kylie_pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

# Custom weights
betweeness_w <- 0.10
citation_w <- 0.20
centrality_w <- 0.30
druggability_w <- 0.40


# Combine scores using custom weights
combined_score <- betweeness_w * betweeness_norm +
  centrality_w * centrality_norm +
  druggability_w * kylie_pcsf_master$druggability -
  citation_w * citation_norm

kylie_pcsf_master_ranked <- cbind(kylie_pcsf_master, combined_score)

kylie_pcsf_master_ranked <- kylie_pcsf_master_ranked[order(-kylie_pcsf_master_ranked$combined_score), ]

rownames(kylie_pcsf_master_ranked) <- NULL

kable(kylie_pcsf_master_ranked, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "800px")
```

<br>

<br>

### Gene subset progression

<br>

```{r data summary, echo=FALSE}
edgeR_hits_dif_exp <- nrow(dif_exp)
ensembl_gene_converted <- nrow(gene_id)
cytoscape_string <- nrow(node_list)
pcsf_subnet <- length(kylie_subnet)
unique_ids <- nrow(kylie_pcsf_master_ranked)

# create summary
cat(paste("Raw gene list =", raw_gene_list, "--> Initial subset (>1 in >=0.5) =", initial_subset))
cat(paste("Initial subset =", initial_subset, "--> EdgeR hits (only dif exp genes) =", edgeR_hits_dif_exp))
cat(paste("EdgeR hits =", edgeR_hits_dif_exp, "--> ensembl gene converted =", ensembl_gene_converted))
cat(paste("ensembl gene converted =", ensembl_gene_converted, "--> Cytoscape/STRING =", cytoscape_string))
cat(paste("Cytoscape/STRING =", cytoscape_string, "--> PCSF subnet =", pcsf_subnet))
cat(paste("PCSF subnet =", pcsf_subnet, "--> Druggability CrossRef =", druggability_crossref))
cat(paste("Druggability CrossRef =", druggability_crossref, "--> Unique IDs =", unique_ids))
```

<br>

<br>

end of doc