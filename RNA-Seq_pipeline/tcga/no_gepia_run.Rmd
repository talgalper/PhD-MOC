---
title: "PCSF: TCGA vs GTEx"
output: html_document
date: "2023-06-02"
---

```{r include=FALSE}
library(PCSF)
library(plyr)
library(biomaRt)
library(dplyr)
library(tidyr)
library(kableExtra)
library(grid)
library(edgeR)
library(ggplot2)
library(reshape2)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(tidyverse)


ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
```

## Description

Healthy ovarian cell RNA-seq data was downloaded from GTEx and differential expression was performed comparing it with data from the TCGA-OV project. 

<br>

## Step 1: Query the TCGA database and obtain TCGA-OV project data. Also load GTEx data

<br>

<details>
<summary> Show code </summary>
```{r eval=FALSE}
# query TCGA for TCGA-OV project data
query_TCGA <- GDCquery(project = "TCGA-OV",
                      experimental.strategy = "RNA-Seq",
                      data.category = "Transcriptome Profiling",
                      data.type = "Gene Expression Quantification",
                      access = "open")

output_query_TCGA <- getResults(query_TCGA)

# check sample types
table(output_query_TCGA$sample_type)


# get clinical data
clinical_query_TCGA_OV <- GDCquery_clinic(project = "TCGA-OV",
                                          type = "clinical")

TCGA_OV_clinical_data <- subset(clinical_query_TCGA_OV, select = c("project", "submitter_id", "figo_stage", "tissue_or_organ_of_origin"))


# combine stage ID with sample info
master_df <- merge(TCGA_OV_clinical_data, output_query_TCGA, by.x = "submitter_id", by.y = "cases.submitter_id")
master_df <- subset(master_df, select = c("project.x", "figo_stage", "cases", "file_name", "sample_type", "tissue_or_organ_of_origin"))
colnames(master_df)[6] <- "primary_site"

# check number of stages included
table(master_df$figo_stage, useNA = "always")

# download and prepare TCGA-OV project data
GDCdownload(query_TCGA, directory = "no_gepia/")

TCGA_OV_data <- GDCprepare(query_TCGA, summarizedExperiment = TRUE, directory = "no_gepia/")
TCGA_OV_data_unstranded <- assay(TCGA_OV_data, "unstranded")

# format rownames
rownames(TCGA_OV_data_unstranded) <- gsub("\\.\\d+", "", rownames(TCGA_OV_data_unstranded))
TCGA_OV_data_unstranded <- as.data.frame(TCGA_OV_data_unstranded)

# load GTEx data
GTEx_raw <- read.table("no_gepia/gene_reads_2017-06-05_v8_ovary.gct", skip = 2, header = T)

# format to match TCGA data
GTEx_data <- GTEx_raw[, -c(1:3)]
rownames(GTEx_data) <- GTEx_raw$Name
rownames(GTEx_data) <- gsub("\\.\\d+", "", rownames(GTEx_data))

save(TCGA_OV_data_unstranded, GTEx_data, file = "no_gepia/TCGA_OV_data_unstranded.RData")
```
</details>

<br>

## Step 2: Subset non-active genes across all samples
```{r echo=FALSE}
load("no_gepia/raw_data.RData")

merged_df <- inner_join(TCGA_OV_data_unstranded, GTEx_data, by = c("row_names_TCGA" = "row_names_GTEx"))

rownames(merged_df) <- merged_df$row_names_TCGA

raw_gene_list <- nrow(merged_df)


colnames(merged_df)[1] <- "gene_id"
gene_id <- merged_df$gene_id
merged_df <- merged_df[, -1] # remove gene ids for rowSums calc

# subset genes that have a cpm of greater than one in more than 50% of the samples
keepTheseGenes <- (rowSums(cpm(merged_df) > 1) >= ncol(merged_df)/2)
print(summary(keepTheseGenes))

# add gene ids back into df
merged_df <- cbind(gene_id, merged_df)

removedGenes <- merged_df$gene_id[!keepTheseGenes]
removedGenes <- as.data.frame(removedGenes)
colnames(removedGenes)[1] <- "gene_id"

merged_df <- merged_df[keepTheseGenes, ]

initial_subset <- nrow(merged_df)
```

<br>

## Step 3: Differential expression analysis using edgeR

```{r echo=FALSE}
merged_df <- merged_df[, -1]

# Select the columns that start with "TCGA"
cols <- grep("^TCGA", colnames(merged_df))

# Assign the unstranded columns to the cancer group
cancer <- colnames(merged_df)[cols]

# Assign the rest of the columns to the healty group
benign <- setdiff(colnames(merged_df), cancer)

# Create the group variable
group <- factor(c(rep("cancer", length(cancer)), rep("benign", length(benign))))

data <- DGEList(counts = merged_df, group = group)

design <- model.matrix(~group)

# Estimate a common negative binomial dispersion parameter for a DGE dataset with a general experimental design
common <- estimateGLMCommonDisp(data, design, verbose = T)

# Estimate the abundance-dispersion trend by Cox-Reid approximate profile likelihood.
trend <- estimateGLMTrendedDisp(common, design)

# Compute an empirical Bayes estimate of the negative binomial dispersion parameter for each tag, 
# with expression levels specified by a log-linear model.
tagwise <- estimateGLMTagwiseDisp(trend, design)

# Fit a negative binomial generalized log-linear model to the read counts for each gene. 
# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
fit <- glmFit(tagwise, design)

# Conduct genewise statistical tests for a given coefficient or coefficient contrast.
lrt <- glmLRT(fit, coef = 2)

# Extract the most differentially expressed genes (or sequence tags) from a test object, 
# ranked either by p-value or by absolute log-fold-change.
toptags <- topTags(lrt, n = Inf)

# Identify which genes are significantly differentially expressed from 
# an edgeR fit object containing p-values and test statistics.
dif_exp <- decideTestsDGE(lrt, p = 0.05, adjust = "fdr", lfc = 2)
print(summary(dif_exp))

dif_exp_genes <- rownames(tagwise)[as.logical(dif_exp)]

# create a results df
hits <- toptags$table[toptags$table$FDR < 0.1, ]
colnames <- colnames(hits)
hits$gene_id <- rownames(hits)
hits <- hits[,c("gene_id", colnames)]

dif_exp <- hits[dif_exp_genes, ]

#write.csv(dif_exp, "no_gepia/edgeR_dif_exp_genes.csv")
```

```{r echo=FALSE, out.width='33%', fig.show='hold'}
# Plot the genewise biological coefficient of variation (BCV) against gene abundance (in log2 counts per million).
plotBCV(tagwise, main = "biological coefficient of variation")

# Make a mean-difference plot of two libraries of count data with smearing of points with very low counts, 
# especially those that are zero for one of the columns.
plotSmear(lrt, de.tags = dif_exp_genes, main = "Mean-difference plot")

# plot Pvalues of different logFC scores
ggplot(hits, aes(x=logFC, y=-log(FDR))) + geom_point() + labs(title = "Adjusted logFC")
```

<br>

## Step 4: PCSF file prep - Create score file and format STRING interaction data

-   Convert gene ensembl to gene symbol

-   Create score file from logFC values

-   Feed list of proteins into STRING/Cytoscape

-   Format output and create interaction file

<br>

<details>
<summary>Show code + removed genes</summary>
```{r}
# read in the data
data <- read.csv("no_gepia/edgeR_dif_exp_genes.csv")

# subset the gene_id and logFC columns
data <- subset(data, select = c("gene_id", "logFC"))

# convert to gene symbol
uniprot_id <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), 
                       filters = "ensembl_gene_id", 
                       values = data$gene_id, 
                       mart = ensembl)

# remove empty rows
uniprot_id <- subset(uniprot_id, external_gene_name != "")

# check for duplicate uniprot ids
uniprot_id <- distinct(uniprot_id)

# merge back with original data
colnames(uniprot_id)[1] <- "gene_id"

uniprot_data <- merge(uniprot_id, data, by = "gene_id")

uniprot_data <- subset(uniprot_data, select = c("external_gene_name", "logFC"))

# check to see if genes that at all genes were converted at least once
missing_genes <- anti_join(data, uniprot_id, by = "gene_id")

# create score file
#write.csv(uniprot_data, "no_gepia/pcsf_score.csv")

## create ensemble protein list for interaction db
#write.table(uniprot_data$external_gene_name, "no_gepia/gene_list.txt", row.names = F, col.names = F, quote = F)
```

```{r echo=FALSE}
string_edge_data <- read.table("no_gepia/STRING network (physical) default edge.csv", header = T, sep = ",", stringsAsFactors = F)
ppi_list <- subset(string_edge_data, select = c("name", "stringdb..score"))
ppi_list <- ppi_list %>% 
  separate(name, sep = " ", into = c("node_1", "del", "node_2"))
ppi_list <- subset(ppi_list, select = c("node_1", "node_2", "stringdb..score"))
ppi_list$node_1 <- gsub(".*.\\.", "", ppi_list$node_1)
ppi_list$node_2 <- gsub(".*.\\.", "", ppi_list$node_2)

string_node_data <- read.table("no_gepia/STRING network (physical) default node.csv", header = T, sep = ",", stringsAsFactors = F)
node_list <- subset(string_node_data, select = c("name", "query.term"))
node_list$name <- gsub(".*.\\.", "", node_list$name)
ppi_list$original_order <- seq_len(nrow(ppi_list))
merged_df <- merge(ppi_list, node_list, by.x = "node_1", by.y = "name", all.x = TRUE)
merged_df <- merge(merged_df, node_list, by.x = "node_2", by.y = "name", all.x = TRUE)
merged_df <- merged_df[order(merged_df$original_order), ]

final_df <- merged_df[, c("query.term.x", "query.term.y", "stringdb..score")]
colnames(final_df) <- c("node_1", "node_2", "score")

#write.csv(final_df, "no_gepia/interaction_score.csv")


# create gene_id uniprot_id ref list.
ref_list <- getBM(attributes = c("external_gene_name","uniprot_gn_id"),
                  filters = "external_gene_name", 
                  values = node_list$query.term, 
                  mart = ensembl)
```
</details>

<br>

## Step 5: Run PCSF and create cross reference results with AF structures for durggability

```{r echo=FALSE}
# set seed for reproducibility 
set.seed(1234)

# read in STRING data
string_data <- read.csv("no_gepia/interaction_score.csv", row.names = 1)

# construct interactome
ppi <- construct_interactome(string_data)

# read in score file
data <- read.csv("no_gepia/pcsf_score.csv", row.names = 1)

# set terminals
terminals <- setNames(as.numeric(data$logFC), data$external_gene_name)

# run PCSF with random noise

# time a pcsf run
start_time <- Sys.time()
subnet <- PCSF_rand(ppi, terminals, n = 50, r = 0.1, w = 2, b = 1, mu = 0.0005)
elapsed_time <- Sys.time() - start_time
print(elapsed_time)

plot.PCSF(subnet, node_label_cex = 15)
```

<br>

```{r include=FALSE}
# extract cluster data
clust <- clusters(subnet)
df <- data.frame(gene_id = names(clust$membership), cluster = factor(clust$membership))
betweenness <- betweenness(subnet) 
centrality <- degree(subnet) 
df$betweenness <- betweenness[as.character(df$gene_id)]
df$degree_centrality <- centrality[as.character(df$gene_id)]
df$betweenness <- as.integer(df$betweenness)
df$degree_centrality <- as.integer(df$degree_centrality)

rownames(df) <- 1:nrow(df)

df <- df[order(df$cluster), ]

#write.csv(df, "no_gepia/pcsf_results.csv", row.names = F)
```

```{r, include=FALSE}
# read in data
af_drugability <- read.csv("~/Desktop/final_copy/pcsf_kylie/fpocket_druggability.csv")
pcsf_result <- read.csv("no_gepia/pcsf_results.csv")
pcsf_result <- merge(ref_list, pcsf_result, by.x = "external_gene_name", by.y = "gene_id")

# merge AF data with PCSF data by uniprot ID
pcsf_master <- merge(pcsf_result, af_drugability, by.x = "uniprot_gn_id", by.y = "uniprot_id")
pcsf_master <- subset(pcsf_master, select = c("external_gene_name", "uniprot_gn_id", "cluster", 
                                                          "betweenness", "degree_centrality", "pocket", 
                                                          "druggability", "num_drug_pockets", "struct_score"))

pcsf_master <- pcsf_master[order(-pcsf_master$druggability), ]

druggability_crossref <- nrow(pcsf_master)

pcsf_master_unique <- distinct(pcsf_master)

#write.csv(pcsf_master, "no_gepia/PCSF_drugability.csv")
```

Note: The citation scores for this data were generated outside this R script using PubMed API

```{r echo=FALSE}
# add up and down regulaiton tags to table
up_or_down <- read.csv("no_gepia/pcsf_score.csv", row.names = 1)
up_or_down$regulation <- ifelse(up_or_down$logFC > 0, "up_reg", "dn_reg")
colnames(up_or_down)[1] <- "gene_id"
pcsf_master <- read.csv("no_gepia/PCSF_drugability.csv", row.names = 1)
pcsf_master <- merge(pcsf_master, up_or_down, by.x = "external_gene_name", by.y = "gene_id")

# run the citation score script now using PCSF_drugability.csv

# add citation scores
cit_scores <- read.csv("no_gepia/citation_scores.csv")
pcsf_master <- merge(pcsf_master, cit_scores, by.x = "external_gene_name", by.y = "gene_id")

pcsf_master <- distinct(pcsf_master)
pcsf_master <- pcsf_master[order(-pcsf_master$druggability), ]
rownames(pcsf_master) <- NULL


# remove duplicates
master_unique <- pcsf_master[!duplicated(pcsf_master$external_gene_name), ]
rownames(master_unique) <- NULL

write.csv(pcsf_master, "no_gepia/pcsf_master.csv")
```

<details>

<summary>Show raw table</summary>

```{r echo=FALSE}
kable(pcsf_master, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

Note: Duplicates removed here

```{r echo=FALSE}
kable(master_unique, format = "html", caption = "PCSF Druggability Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<details>

```{r eval=FALSE}
# dont need it, doenst work

subset_genes <- as.data.frame(pcsf_master$gene_id)
colnames(subset_genes)[1] <- "gene_id"

network_out_genes <- anti_join(uniprot_id, subset_genes, by = "gene_id")

kable(network_out_genes, format = "html", caption = "Removed genes from cytoscape + network + druggability filters") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

## Step 4: Functional Enrichment Analysis

<details>

<summary>Show code</summary>

```{r echo=FALSE}
enrichment_analysis_edit <-function(subnet, mode=NULL, gene_universe){
  
  # Checking function arguments
  if (missing(subnet))
    stop("Need to specify the subnetwork obtained from the PCSF algorithm.")
  if (class(subnet)[1] != "PCSF" || class(subnet)[2] != "igraph")
    stop("The subnetwork must be a \"PCSF\" object derived from an \"igraph\" class.")
  if (!is.null(mode)){
    if(mode==1 && missing(gene_universe))
      stop("Need to specify a list of genes (vector of gene symbols) used as background in enrichment analysis by topGO package")
  }
  
  
  cat("  Performing enrichment analysis...\n\n")
  
  # Obtain clusters in the subnet using edge betweenness clustering algorithm from igraph package.
  clusters = cluster_edge_betweenness(subnet)
  
  # Perform ebrichment analysis for each cluster using EnrichR through its API or topGO.
  #print("Performing enrichment analysis...")
  #print(paste("Number of clusters:", length(clusters$membership)))
  
  havingInternet <- function() {
    if (.Platform$OS.type == "windows") {
      ipmessage <- system("ipconfig", intern = TRUE)
    } else {
      ipmessage <- system("ifconfig", intern = TRUE)
    }
    validIP <- "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)[.]){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    any(grep(validIP, ipmessage))
  }
  
  internet_connection <- havingInternet()
  
  if(!is.null(mode)){
    if(mode==0){
      if(internet_connection){
        cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
        enrich = call_enr(clusters, mode = 0, gene_universe)
      }
      else{
        stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
      }
    }
    else{
      cat("  Enrichment is being performed by topGO package ...\n")
      enrich = call_enr(clusters, mode = mode, gene_universe)
    }
  }
  else
  {
    if(internet_connection){
      cat("  Enrichment is being performed by EnrichR (http://amp.pharm.mssm.edu/Enrichr) API ...\n")
      enrich = call_enr(clusters, mode = 0, gene_universe)
    }
    else{
      stop("There is no working Internet connection, perform your enrichment with topGO package with mode=1 by providing background gene list ...\n")
    }
  }
  
  if('Compound'%in% V(subnet)$type){##then we have drugs!
    require(dplyr)
    comps=data.frame(Drug=V(subnet)$name[which(V(subnet)$type=='Compound')],
                     Cluster=clusters$membership[which(V(subnet)$type=='Compound')])%>%
      dplyr::group_by(Cluster)%>%
      dplyr::summarise(DrugsByBetweenness=paste(Drug,collapse=';'))
    
  }
  else{
    comps <-NULL
  }
  enrichment = enrich[[1]]
  enrichment_complete = enrich[[2]]
  print(paste("Number of enrichment results:", length(enrichment_complete)))
  
  #for (x in 1:length(enrichment_complete)) {
  #  print(paste("Cluster", x, "enrichment complete:", enrichment_complete[[x]]))
  #}
  
  novals<-which(unlist(sapply(enrich[[2]],function(x) is.null(dim(x)))))
  if(length(novals)>0)
    enrichment_complete <- enrichment_complete[-novals]
  
  enrichment_tab <- do.call(rbind, lapply(seq_along(enrichment_complete), function(x) {
    if (!is.null(dim(enrichment_complete[[x]]))) {
      data.frame(Cluster = x, enrichment_complete[[x]])
    } else {
      NULL
    }
  }))
  
  more.than.two <- which(sapply(enrichment_tab$Genes, function(x) length(unlist(strsplit(x, split = ';')))) > 2)
  if (length(more.than.two) > 0)
    enrichment_tab <- enrichment_tab[more.than.two, ]
  
  if(!is.null(comps))
    enrichment_tab = enrichment_tab%>%dplyr::left_join(comps,by='Cluster')
  
  # Add 'group" and 'title' attributes to subnet
  V(subnet)$group = clusters$membership
  V(subnet)$title = paste0("Cluster ",clusters$membership,": Enrichment analysis")
  for( i in 1:length(V(subnet))){
    V(subnet)$title[i] = paste0( V(subnet)$title[i], enrichment[[V(subnet)$group[i]]])
  }
  
  # Derive a "PCSFe" object from an "igraph" class.
  class(subnet) <- c("PCSFe", "igraph")
  # Combine the subnetwork and colplete enrichment analysis tables.
  output = list(subnet, enrichment_tab)
  names(output) = c("subnet", "enrichment")
  
  return (output)
}

# functional enrichment using enrichR
res <- enrichment_analysis_edit(subnet)
```

</details>

<br>

#### Tip: Hover over nodes for details!

```{r echo=FALSE}
plot.PCSFe(res$subnet, edge_width = 8, node_size = 30, node_label_cex = 1)
```

<br>

Note: P-value represents likelihood of observing that pathway by random chance. The top 15 functional enrichment terms for each cluster are ranked according to the adjusted p-value. This is what you observe when you hover your mouse over a node in that cluster.

<br>

```{r include=FALSE}
enrichment_results <- res$enrichment

# Create a data frame with the enrichment results
enrichment_table <- data.frame(
  Cluster = enrichment_results$Cluster,
  Term = enrichment_results$Term,
  PValue = enrichment_results$P.value,
  Adjusted_Pvalue = enrichment_results$Adjusted.P.value,
  Genes = enrichment_results$Genes)

write.csv(enrichment_table, "no_gepia/enrichment_results.csv")
```

#### Tabulated format

```{r echo=FALSE}
enrichment_table <- read.csv("no_gepia/enrichment_results.csv", row.names = 1)
  
kable(enrichment_table, format = "html", caption = "Enrichment Results") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<br>

In this table the genes are ordered by their combined rank score which is a normalised score with the following contributions.

<br>

-   Betweeness: 10%
-   Citation score: 20%
-   Degree centrality: 30%
-   Druggability: 40%

<br>

```{r echo=FALSE}
# normalize scores for overall rank
pcsf_master <- read.csv("no_gepia/pcsf_master.csv", row.names = 1)

betweeness_norm <- (pcsf_master$betweenness - min(pcsf_master$betweenness)) / (max(pcsf_master$betweenness) - min(pcsf_master$betweenness))

centrality_norm <- (pcsf_master$degree_centrality - min(pcsf_master$degree_centrality)) / (max(pcsf_master$degree_centrality) - min(pcsf_master$degree_centrality))

# log transformation
citation_norm <- log(pcsf_master$citation_score + 1)
citation_norm <- (citation_norm - min(citation_norm)) / (max(citation_norm) - min(citation_norm))

# Custom weights
betweeness_w <- 0.10
citation_w <- 0.20
centrality_w <- 0.30
druggability_w <- 0.40


# Combine scores using custom weights
combined_score <- betweeness_w * betweeness_norm +
  centrality_w * centrality_norm +
  druggability_w * pcsf_master$druggability -
  citation_w * citation_norm

pcsf_master_edit <- cbind(pcsf_master, combined_score)

pcsf_master_edit <- pcsf_master_edit[order(-pcsf_master_edit$combined_score), ]

pcsf_master_edit_unique <- pcsf_master_edit[!duplicated(pcsf_master_edit$external_gene_name), ]

rownames(pcsf_master_edit) <- NULL

kable(pcsf_master_edit, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

<details>

<summary>Show unique genes only</summary>

```{r}
kable(pcsf_master_edit_unique, format = "html", caption = "Ordered by Combined Rank Score") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

</details>

<br>

```{r echo=FALSE, eval=FALSE}
# all this is wrong, figure out how to compare enrichment to the original network to see which genes are different

network_genes <- as.data.frame(V(subnet)$name)
colnames(network_genes)[1] <- "external_gene_name"

enrichment_genes <- res$enrichment$Genes
enrichment_genes <- strsplit(enrichment_genes, ";")
enrichment_genes <- unlist(enrichment_genes)
enrichment_genes <- as.data.frame(trimws(enrichment_genes))
colnames(enrichment_genes)[1] <- "external_gene_name"

network_out_genes <- anti_join(network_genes, enrichment_genes, by = "external_gene_name")

kable(network_out_genes, format = "html", caption = "Removed genes from cytoscape + network + druggability filters") %>%
kable_styling(full_width = FALSE) %>%
scroll_box(height = "400px")
```

<br>

### Gene subset progression

<br>

```{r echo=FALSE}
edgeR_hits_dif_exp <- nrow(dif_exp)
ensembl_gene_converted <- nrow(uniprot_id)
cytoscape_string <- nrow(node_list)
pcsf_subnet <- length(subnet)
unique_ids <- nrow(pcsf_master_edit_unique)

# create summary
cat(paste("Raw gene list =", raw_gene_list, "--> Initial subset (>1 in >=0.5) =", initial_subset))
cat(paste("Initial subset =", initial_subset, "--> EdgeR hits (only dif exp genes) =", edgeR_hits_dif_exp))
cat(paste("EdgeR hits =", edgeR_hits_dif_exp, "--> ensembl gene converted =", ensembl_gene_converted))
cat(paste("ensembl gene converted =", ensembl_gene_converted, "--> Cytoscape/STRING =", cytoscape_string))
cat(paste("Cytoscape/STRING =", cytoscape_string, "--> PCSF subnet =", pcsf_subnet))
cat(paste("PCSF subnet =", pcsf_subnet, "--> Druggability CrossRef =", druggability_crossref))
cat(paste("Druggability CrossRef =", druggability_crossref, "--> Unique IDs =", unique_ids))
```

<br>

<br>

end of doc